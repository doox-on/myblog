---
title: Natural Language → SQL with LLMs
feature_image: "https://picsum.photos/2560/600?image=1024"
---

For one of my reproducibility assignments, I explored how Large Language Models (LLMs) can **translate natural language questions into SQL queries**.  
The project repo provided two pipelines: one using the **Groq API** with real-time LLM calls, and another designed for a **locally fine-tuned model** with LoRA and ReAct prompting.  

I focused on the API-based pipeline: giving it a question like  
> *“For each zipcode, give the change in average house rent from 2019 to 2022.”*  
and watching the system break it into smaller SQL sub-queries, run them on a SQLite database, and then compose a final SQL query.  

It was surprisingly satisfying to see a plain English sentence get turned into a valid SQL statement that actually ran against the database. 

---

### Overview

The repo is structured with multiple parts:  
<ul style="font-size: 1.6rem; line-height: 1.6; text-align: center; margin: 0;">
  <li style="list-style: none; margin: 0px 0;">
    <a href="https://github.gatech.edu/asreeraj3/iec-norp-llm?tab=readme-ov-file#2-local-finetuned-model-conversion" 
       style="font-size: 1.3rem; text-decoration: none;">
      The Original Repo
    </a>
  </li>
</ul>

1. **Data augmentation** scripts (`augment_ods.py`) that paraphrase queries to make the dataset more robust.  
2. **SQLite utilities** (`pull_table_csv.py`, `sqlite_maker.py`) to build the database from CSV files.  
3. **Evaluation scripts** (`query_tester.py`, `query_comparator.py`) that compare predicted SQL queries with the ground truth using metrics like *Exact Match, Execution Match, Structural Similarity, and Output Similarity*.  
4. **Agents**:  
   - `agent.py` → connects to the Groq API, decomposes natural language queries, and synthesizes final SQL queries.  
   - `NL2SQL_finetuned.py` → (optional) a locally fine-tuned Llama model with LoRA and ReAct reasoning loops.  

---

### Running the Agent

When I ran `agent.py`, the pipeline:  

- Took in my NLQ.  
- Decomposed it into **sub-queries** with reasoning steps.  
- Executed each sub-query on the SQLite database.  
- Re-assembled the results into a final SQL query.  

It even showed intermediate outputs, so I could trace *why* the model built the final SQL the way it did.  

{% include figure.html image="assets/norp_sql.png" title="Example: NLQ decomposed into SQL sub-queries" %}

```txt
[INFO] Initialising Groq client...
[INFO] Connecting to sqlite3 database 'my_database.db'...
[INFO] LLMAgent initialised using model: llama-3.1-8b-instant

[PIPELINE] Running NLQ to SQL conversion...

[PIPELINE] Starting NLQ to SQL conversion pipeline...

[STEP] Decomposing NLQ into sub-queries with reasons...

[STEP] Sending prompt to Groq LLM:
Given the following SQL schema:
housing_rent (year, id, zipcode, number_of_units, rent_value_min, 
rent_value_max)

And the complex natural language query:
For each zipcode, give the change in average house rent from 2019 to 2022.

Decide on some subqueries that are relevant to this natural language query. get 
a list of simpler SQL sub-queries that, when executed, provide context to answer
the overall question. For each sub-query, also provide a brief explanation (a 
'reason') of why that sub-query is important to the main question. Return the 
output as a markdown code snippet formatted in JSON with the following schema:

json
{
    "subqueries": [
        { "query": "<SQL query>", "reason": "<brief explanation>" },
        ...
    ]
}


The output should be a markdown code snippet formatted in the following schema, 
including the leading and trailing "json" and "":

json
{
        "subqueries": string  // A JSON object with a key 'subqueries' whose 
value is an array of objects. Each object must contain two keys: 'query', which 
is a valid SQL query that uses only the columns from the provided schema, and 
'reason', which is a brief explanation of why that query is important to answer 
the main question. Do not include any extra commentary or numbering.
}

[STEP] Received completion:
json
{
    "subqueries": [
        {
            "query": "SELECT year, zipcode, AVG(rent_value_min) AS avg_rent_min,
AVG(rent_value_max) AS avg_rent_max FROM housing_rent GROUP BY year, zipcode",
            "reason": "This subquery calculates the average minimum and maximum 
rent for each zipcode in each year, providing the necessary data to compute the 
change in average house rent."
        },
        {
            "query": "SELECT zipcode FROM housing_rent WHERE year = 2019",
            "reason": "This subquery retrieves the list of unique zipcodes from 
the 2019 data, serving as a baseline for the average house rent calculation."
        },
        {
            "query": "SELECT zipcode FROM housing_rent WHERE year = 2022",
            "reason": "This subquery retrieves the list of unique zipcodes from 
the 2022 data, determining the relevant zipcodes for the final comparison."
        },
        {
            "query": "SELECT avg_rent_min_2019, avg_rent_max_2019, 
avg_rent_min_2022, avg_rent_max_2022 FROM (SELECT zipcode, AVG(rent_value_min) 
AS avg_rent_min, AVG(rent_value_max) AS avg_rent_max FROM housing_rent WHERE 
year = 2019 GROUP BY zipcode) AS rent_2019 JOIN (SELECT zipcode, 
AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) AS avg_rent_max FROM 
housing_rent WHERE year = 2022 GROUP BY zipcode) AS rent_2022 ON 
rent_2019.zipcode = rent_2022.zipcode",
            "reason": "This subquery pairs each zipcode's average rent from 2019
and 2022, enabling the computation of the change in average house rent."
        },
        {
            "query": "SELECT zipfiled FROM (SELECT zipcode, avg_rent_min_2019, 
avg_rent_max_2019, avg_rent_min_2022, avg_rent_max_2022 FROM (SELECT zipcode, 
AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) AS avg_rent_max FROM 
housing_rent WHERE year = 2019 GROUP BY zipcode) AS rent_2019 JOIN (SELECT 
zipcode, AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) AS 
avg_rent_max FROM housing_rent WHERE year = 2022 GROUP BY zipcode) AS rent_2022 
ON rent_2019.zipcode = rent_2022.zipcode) AS paired_rents (SELECT zipcode, 
((avg_rent_min_2022 - avg_rent_min_2019) / avg_rent_min_2019) * 100 AS 
percent_change_min, ((avg_rent_max_2022 - avg_rent_max_2019) / 
avg_rent_max_2019) * 100 AS percent_change_max FROM paired_rents) ",
            "reason": "This subquery calculates the percent change of average 
minimum and maximum rent from 2019 to 2022 for each zipcode."
        },
        {
            "query": "SELECT zipcode, percent_change_min, percent_change_max 
FROM paired_rents ORDER BY zipcode, percent_change_min, percent_change_max",
            "reason": "This subquery reorders the data by zipcode and average 
rent change, facilitating the visualization of key trends in the percent change 
of average house rent."
        }
    ]
}

[INFO] Parsed SQL sub-queries with reasons:
Query: SELECT year, zipcode, AVG(rent_value_min) AS avg_rent_min, 
AVG(rent_value_max) AS avg_rent_max FROM housing_rent GROUP BY year, zipcode
Reason: This subquery calculates the average minimum and maximum rent for each 
zipcode in each year, providing the necessary data to compute the change in 
average house rent.
Query: SELECT zipcode FROM housing_rent WHERE year = 2019
Reason: This subquery retrieves the list of unique zipcodes from the 2019 data, 
serving as a baseline for the average house rent calculation.
Query: SELECT zipcode FROM housing_rent WHERE year = 2022
Reason: This subquery retrieves the list of unique zipcodes from the 2022 data, 
determining the relevant zipcodes for the final comparison.
Query: SELECT avg_rent_min_2019, avg_rent_max_2019, avg_rent_min_2022, 
avg_rent_max_2022 FROM (SELECT zipcode, AVG(rent_value_min) AS avg_rent_min, 
AVG(rent_value_max) AS avg_rent_max FROM housing_rent WHERE year = 2019 GROUP BY
zipcode) AS rent_2019 JOIN (SELECT zipcode, AVG(rent_value_min) AS avg_rent_min,
AVG(rent_value_max) AS avg_rent_max FROM housing_rent WHERE year = 2022 GROUP BY
zipcode) AS rent_2022 ON rent_2019.zipcode = rent_2022.zipcode
Reason: This subquery pairs each zipcode's average rent from 2019 and 2022, 
enabling the computation of the change in average house rent.
Query: SELECT zipfiled FROM (SELECT zipcode, avg_rent_min_2019, 
avg_rent_max_2019, avg_rent_min_2022, avg_rent_max_2022 FROM (SELECT zipcode, 
AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) AS avg_rent_max FROM 
housing_rent WHERE year = 2019 GROUP BY zipcode) AS rent_2019 JOIN (SELECT 
zipcode, AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) AS 
avg_rent_max FROM housing_rent WHERE year = 2022 GROUP BY zipcode) AS rent_2022 
ON rent_2019.zipcode = rent_2022.zipcode) AS paired_rents (SELECT zipcode, 
((avg_rent_min_2022 - avg_rent_min_2019) / avg_rent_min_2019) * 100 AS 
percent_change_min, ((avg_rent_max_2022 - avg_rent_max_2019) / 
avg_rent_max_2019) * 100 AS percent_change_max FROM paired_rents) 
Reason: This subquery calculates the percent change of average minimum and 
maximum rent from 2019 to 2022 for each zipcode.
Query: SELECT zipcode, percent_change_min, percent_change_max FROM paired_rents 
ORDER BY zipcode, percent_change_min, percent_change_max
Reason: This subquery reorders the data by zipcode and average rent change, 
facilitating the visualization of key trends in the percent change of average 
house rent.

[STEP] Validating sub-queries on the database...
[INFO] Executed: SELECT year, zipcode, AVG(rent_value_min) AS avg_rent_min, 
AVG(rent_value_max) AS avg_rent_max FROM housing_rent GROUP BY year, zipcode
[INFO] Results (first 5 rows): [(2015, 'ZCTA5 30004', 1750.0, 
2499.1666666666665), (2015, 'ZCTA5 30005', 1500.0, 2213.4285714285716), (2015, 
'ZCTA5 30008', 1500.0, 2213.4285714285716), (2015, 'ZCTA5 30009', 1500.0, 
2213.4285714285716), (2015, 'ZCTA5 30011', 1500.0, 2213.4285714285716)] ... 
(total 5906 rows)
[INFO] Executed: SELECT zipcode FROM housing_rent WHERE year = 2019
[INFO] Results (first 5 rows): [('ZCTA5 30004',), ('ZCTA5 30004',), ('ZCTA5 
30004',), ('ZCTA5 30004',), ('ZCTA5 30004',)] ... (total 5138 rows)
[INFO] Executed: SELECT zipcode FROM housing_rent WHERE year = 2022
[INFO] Results (first 5 rows): [('ZCTA5 30004',), ('ZCTA5 30004',), ('ZCTA5 
30004',), ('ZCTA5 30004',), ('ZCTA5 30004',)] ... (total 5257 rows)
[ERROR] Failed to execute query: SELECT avg_rent_min_2019, avg_rent_max_2019, 
avg_rent_min_2022, avg_rent_max_2022 FROM (SELECT zipcode, AVG(rent_value_min) 
AS avg_rent_min, AVG(rent_value_max) AS avg_rent_max FROM housing_rent WHERE 
year = 2019 GROUP BY zipcode) AS rent_2019 JOIN (SELECT zipcode, 
AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) AS avg_rent_max FROM 
housing_rent WHERE year = 2022 GROUP BY zipcode) AS rent_2022 ON 
rent_2019.zipcode = rent_2022.zipcode. Error: no such column: avg_rent_min_2019
[ERROR] Failed to execute query: SELECT zipfiled FROM (SELECT zipcode, 
avg_rent_min_2019, avg_rent_max_2019, avg_rent_min_2022, avg_rent_max_2022 FROM 
(SELECT zipcode, AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) AS 
avg_rent_max FROM housing_rent WHERE year = 2019 GROUP BY zipcode) AS rent_2019 
JOIN (SELECT zipcode, AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) 
AS avg_rent_max FROM housing_rent WHERE year = 2022 GROUP BY zipcode) AS 
rent_2022 ON rent_2019.zipcode = rent_2022.zipcode) AS paired_rents (SELECT 
zipcode, ((avg_rent_min_2022 - avg_rent_min_2019) / avg_rent_min_2019) * 100 AS 
percent_change_min, ((avg_rent_max_2022 - avg_rent_max_2019) / 
avg_rent_max_2019) * 100 AS percent_change_max FROM paired_rents) . Error: near 
"(": syntax error
[ERROR] Failed to execute query: SELECT zipcode, percent_change_min, 
percent_change_max FROM paired_rents ORDER BY zipcode, percent_change_min, 
percent_change_max. Error: no such table: paired_rents

[STEP] Composing final SQL query using sub-query outputs...
[INFO] Detailed context for final query:
Sub-query: SELECT year, zipcode, AVG(rent_value_min) AS avg_rent_min, 
AVG(rent_value_max) AS avg_rent_max FROM housing_rent GROUP BY year, zipcode
Reason: This subquery calculates the average minimum and maximum rent for each 
zipcode in each year, providing the necessary data to compute the change in 
average house rent.
Status: success
Results (first 5 rows): [(2015, 'ZCTA5 30004', 1750.0, 2499.1666666666665), 
(2015, 'ZCTA5 30005', 1500.0, 2213.4285714285716), (2015, 'ZCTA5 30008', 1500.0,
2213.4285714285716), (2015, 'ZCTA5 30009', 1500.0, 2213.4285714285716), (2015, 
'ZCTA5 30011', 1500.0, 2213.4285714285716)] ... (total 5906 rows)

Sub-query: SELECT zipcode FROM housing_rent WHERE year = 2019
Reason: This subquery retrieves the list of unique zipcodes from the 2019 data, 
serving as a baseline for the average house rent calculation.
Status: success
Results (first 5 rows): [('ZCTA5 30004',), ('ZCTA5 30004',), ('ZCTA5 30004',), 
('ZCTA5 30004',), ('ZCTA5 30004',)] ... (total 5138 rows)

Sub-query: SELECT zipcode FROM housing_rent WHERE year = 2022
Reason: This subquery retrieves the list of unique zipcodes from the 2022 data, 
determining the relevant zipcodes for the final comparison.
Status: success
Results (first 5 rows): [('ZCTA5 30004',), ('ZCTA5 30004',), ('ZCTA5 30004',), 
('ZCTA5 30004',), ('ZCTA5 30004',)] ... (total 5257 rows)

Sub-query: SELECT avg_rent_min_2019, avg_rent_max_2019, avg_rent_min_2022, 
avg_rent_max_2022 FROM (SELECT zipcode, AVG(rent_value_min) AS avg_rent_min, 
AVG(rent_value_max) AS avg_rent_max FROM housing_rent WHERE year = 2019 GROUP BY
zipcode) AS rent_2019 JOIN (SELECT zipcode, AVG(rent_value_min) AS avg_rent_min,
AVG(rent_value_max) AS avg_rent_max FROM housing_rent WHERE year = 2022 GROUP BY
zipcode) AS rent_2022 ON rent_2019.zipcode = rent_2022.zipcode
Reason: This subquery pairs each zipcode's average rent from 2019 and 2022, 
enabling the computation of the change in average house rent.
Status: failure
Error: no such column: avg_rent_min_2019

Sub-query: SELECT zipfiled FROM (SELECT zipcode, avg_rent_min_2019, 
avg_rent_max_2019, avg_rent_min_2022, avg_rent_max_2022 FROM (SELECT zipcode, 
AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) AS avg_rent_max FROM 
housing_rent WHERE year = 2019 GROUP BY zipcode) AS rent_2019 JOIN (SELECT 
zipcode, AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) AS 
avg_rent_max FROM housing_rent WHERE year = 2022 GROUP BY zipcode) AS rent_2022 
ON rent_2019.zipcode = rent_2022.zipcode) AS paired_rents (SELECT zipcode, 
((avg_rent_min_2022 - avg_rent_min_2019) / avg_rent_min_2019) * 100 AS 
percent_change_min, ((avg_rent_max_2022 - avg_rent_max_2019) / 
avg_rent_max_2019) * 100 AS percent_change_max FROM paired_rents) 
Reason: This subquery calculates the percent change of average minimum and 
maximum rent from 2019 to 2022 for each zipcode.
Status: failure
Error: near "(": syntax error

Sub-query: SELECT zipcode, percent_change_min, percent_change_max FROM 
paired_rents ORDER BY zipcode, percent_change_min, percent_change_max
Reason: This subquery reorders the data by zipcode and average rent change, 
facilitating the visualization of key trends in the percent change of average 
house rent.
Status: failure
Error: no such table: paired_rents

[STEP] Sending prompt to Groq LLM:
Given the following detailed context for each sub-query:
Sub-query: SELECT year, zipcode, AVG(rent_value_min) AS avg_rent_min, 
AVG(rent_value_max) AS avg_rent_max FROM housing_rent GROUP BY year, zipcode
Reason: This subquery calculates the average minimum and maximum rent for each 
zipcode in each year, providing the necessary data to compute the change in 
average house rent.
Status: success
Results (first 5 rows): [(2015, 'ZCTA5 30004', 1750.0, 2499.1666666666665), 
(2015, 'ZCTA5 30005', 1500.0, 2213.4285714285716), (2015, 'ZCTA5 30008', 1500.0,
2213.4285714285716), (2015, 'ZCTA5 30009', 1500.0, 2213.4285714285716), (2015, 
'ZCTA5 30011', 1500.0, 2213.4285714285716)] ... (total 5906 rows)

Sub-query: SELECT zipcode FROM housing_rent WHERE year = 2019
Reason: This subquery retrieves the list of unique zipcodes from the 2019 data, 
serving as a baseline for the average house rent calculation.
Status: success
Results (first 5 rows): [('ZCTA5 30004',), ('ZCTA5 30004',), ('ZCTA5 30004',), 
('ZCTA5 30004',), ('ZCTA5 30004',)] ... (total 5138 rows)

Sub-query: SELECT zipcode FROM housing_rent WHERE year = 2022
Reason: This subquery retrieves the list of unique zipcodes from the 2022 data, 
determining the relevant zipcodes for the final comparison.
Status: success
Results (first 5 rows): [('ZCTA5 30004',), ('ZCTA5 30004',), ('ZCTA5 30004',), 
('ZCTA5 30004',), ('ZCTA5 30004',)] ... (total 5257 rows)

Sub-query: SELECT avg_rent_min_2019, avg_rent_max_2019, avg_rent_min_2022, 
avg_rent_max_2022 FROM (SELECT zipcode, AVG(rent_value_min) AS avg_rent_min, 
AVG(rent_value_max) AS avg_rent_max FROM housing_rent WHERE year = 2019 GROUP BY
zipcode) AS rent_2019 JOIN (SELECT zipcode, AVG(rent_value_min) AS avg_rent_min,
AVG(rent_value_max) AS avg_rent_max FROM housing_rent WHERE year = 2022 GROUP BY
zipcode) AS rent_2022 ON rent_2019.zipcode = rent_2022.zipcode
Reason: This subquery pairs each zipcode's average rent from 2019 and 2022, 
enabling the computation of the change in average house rent.
Status: failure
Error: no such column: avg_rent_min_2019

Sub-query: SELECT zipfiled FROM (SELECT zipcode, avg_rent_min_2019, 
avg_rent_max_2019, avg_rent_min_2022, avg_rent_max_2022 FROM (SELECT zipcode, 
AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) AS avg_rent_max FROM 
housing_rent WHERE year = 2019 GROUP BY zipcode) AS rent_2019 JOIN (SELECT 
zipcode, AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) AS 
avg_rent_max FROM housing_rent WHERE year = 2022 GROUP BY zipcode) AS rent_2022 
ON rent_2019.zipcode = rent_2022.zipcode) AS paired_rents (SELECT zipcode, 
((avg_rent_min_2022 - avg_rent_min_2019) / avg_rent_min_2019) * 100 AS 
percent_change_min, ((avg_rent_max_2022 - avg_rent_max_2019) / 
avg_rent_max_2019) * 100 AS percent_change_max FROM paired_rents) 
Reason: This subquery calculates the percent change of average minimum and 
maximum rent from 2019 to 2022 for each zipcode.
Status: failure
Error: near "(": syntax error

Sub-query: SELECT zipcode, percent_change_min, percent_change_max FROM 
paired_rents ORDER BY zipcode, percent_change_min, percent_change_max
Reason: This subquery reorders the data by zipcode and average rent change, 
facilitating the visualization of key trends in the percent change of average 
house rent.
Status: failure
Error: no such table: paired_rents

And the original natural language query:
For each zipcode, give the change in average house rent from 2019 to 2022.

Compose a final, comprehensive SQL query that answers the natural language query
using the provided context. Return only the SQL query in a markdown code snippet
formatted as follows:

json
{
    "sql": "<your SQL query here>"
}

[STEP] Received completion:
json
{
    "sql": "SELECT r.zipcode, ((r.avg_rent_min_2022 - r.avg_rent_min_2019) / 
r.avg_rent_min_2019) * 100 AS percent_change_min, ((r.avg_rent_max_2022 - 
r.avg_rent_max_2019) / r.avg_rent_max_2019) * 100 AS percent_change_max 
             FROM (SELECT zipcode, avg_rent_min_2019, avg_rent_max_2019, 
avg_rent_min_2022, avg_rent_max_2022 
                  FROM (SELECT zipcode, AVG(rent_value_min) AS avg_rent_min, 
AVG(rent_value_max) AS avg_rent_max 
                      FROM housing_rent WHERE year = 2019 GROUP BY zipcode) AS 
rent_2019 
                  JOIN (SELECT zipcode, AVG(rent_value_min) AS avg_rent_min, 
AVG(rent_value_max) AS avg_rent_max 
                      FROM housing_rent WHERE year = 2022 GROUP BY zipcode) AS 
rent_2022 
                  ON rent_2019.zipcode = rent_2022.zipcode) AS r 
             ORDER BY r.zipcode, r.percent_change_min, r.percent_change_max"
}

[INFO] Final composed SQL query:
SELECT r.zipcode, ((r.avg_rent_min_2022 - r.avg_rent_min_2019) / 
r.avg_rent_min_2019) * 100 AS percent_change_min, ((r.avg_rent_max_2022 - 
r.avg_rent_max_2019) / r.avg_rent_max_2019) * 100 AS percent_change_max         
FROM (SELECT zipcode, avg_rent_min_2019, avg_rent_max_2019, avg_rent_min_2022, 
avg_rent_max_2022                    FROM (SELECT zipcode, AVG(rent_value_min) 
AS avg_rent_min, AVG(rent_value_max) AS avg_rent_max                        FROM
housing_rent WHERE year = 2019 GROUP BY zipcode) AS rent_2019                   
JOIN (SELECT zipcode, AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) 
AS avg_rent_max                        FROM housing_rent WHERE year = 2022 GROUP
BY zipcode) AS rent_2022                    ON rent_2019.zipcode = 
rent_2022.zipcode) AS r               ORDER BY r.zipcode, r.percent_change_min, 
r.percent_change_max

[PIPELINE] Pipeline completed.

Final SQL Query:
SELECT r.zipcode, ((r.avg_rent_min_2022 - r.avg_rent_min_2019) / 
r.avg_rent_min_2019) * 100 AS percent_change_min, ((r.avg_rent_max_2022 - 
r.avg_rent_max_2019) / r.avg_rent_max_2019) * 100 AS percent_change_max         
FROM (SELECT zipcode, avg_rent_min_2019, avg_rent_max_2019, avg_rent_min_2022, 
avg_rent_max_2022                    FROM (SELECT zipcode, AVG(rent_value_min) 
AS avg_rent_min, AVG(rent_value_max) AS avg_rent_max                        FROM
housing_rent WHERE year = 2019 GROUP BY zipcode) AS rent_2019                   
JOIN (SELECT zipcode, AVG(rent_value_min) AS avg_rent_min, AVG(rent_value_max) 
AS avg_rent_max                        FROM housing_rent WHERE year = 2022 GROUP
BY zipcode) AS rent_2022                    ON rent_2019.zipcode = 
rent_2022.zipcode) AS r               ORDER BY r.zipcode, r.percent_change_min, 
r.percent_change_max
```


---

### Evaluation

To test accuracy, I used `query_tester.py`.  
By default, it has a **dummy SQL generator** (`SELECT * FROM <table>`) which gave predictably low scores (Exact Match = 0, Structural Similarity ≈ 0.12).  
Still, the evaluation framework worked as expected, showing how well generated SQL queries can be measured against real ground truth.  

{% include figure.html image="assets/query_tester.png" title="query_tester.py" %}

```txt
Test 1:
  NLQ: For each zipcode in Atlanta, give the change in average house rent from 2019 to 2022, i.e., from pre-COVID to post-COVID period.
  Predicted SQL: SELECT * FROM housing_rent;
  Ground Truth SQL: select substring(housing_rent.zipcode, 7, 10) as zcta, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) - h.rent_weighted_avg as decimal(8,2)) as rent_change
from housing_rent join 
(select zipcode, (sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as rent_weighted_avg
from housing_rent where year=2019 group by zipcode) as h on h.zipcode=housing_rent.zipcode
where year=2022 
group by housing_rent.zipcode
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.055
  Output Similarity: 0.000
  Execution Time: 0.063 seconds

Test 2:
  NLQ: Get year-on-year change in GRAPI, where GRAPI is gross rent as percentage of household income.
  Predicted SQL: SELECT * FROM housing_gross_rent_percent;
  Ground Truth SQL: select str_to_date(concat(year,'-01-01'),'%Y-%m-%d') as `Year`, sum(number_of_units*(income_percent_max+income_percent_min)/2)/sum(number_of_units) as `GRAPI`
from housing_gross_rent_percent
group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.200
  Output Similarity: 0.000
  Execution Time: 0.056 seconds

Test 3:
  NLQ: Get year-on-year change in SMOCAPI, where SMOCAPI is selected monthly home-ownership costs as a percent of household income
  Predicted SQL: SELECT * FROM household_income_percent_with_mortgage;
  Ground Truth SQL: select str_to_date(concat(year,'-01-01'),'%Y-%m-%d') as `Year`, sum(number_of_units*(income_percent_max+income_percent_min)/2)/sum(number_of_units) as `SMOCAPI`
from household_income_percent_with_mortgage
group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.242
  Output Similarity: 0.000
  Execution Time: 0.043 seconds

Test 4:
  NLQ: For each zipcode in Georgia, give the change in average house rent from 2017 to 2022.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select substring(housing_value.zipcode, 7, 10) as zcta, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) - h.housing_value_weighted_avg as decimal(8,2)) as change_in_housing_value
from housing_value join 
(select zipcode, (sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as housing_value_weighted_avg
from housing_value where year=2017 group by zipcode) as h on h.zipcode=housing_value.zipcode
where year=2022 
group by housing_value.zipcode
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.053
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 5:
  NLQ: For year 2017, get zipcodes in Georgia where SMOCAPI is greater than 28.
  Predicted SQL: SELECT * FROM household_income_percent_without_mortgage;
  Ground Truth SQL: select substring(household_income_percent_with_mortgage.zipcode, 7, 10) as zcta, sum(number_of_units*(income_percent_min+income_percent_max)/2)/sum(number_of_units) as `Change in monthly home-ownership costs as a percentage of household income` from household_income_percent_with_mortgage 
where year=2017
group by household_income_percent_with_mortgage.zipcode
having `Change in monthly home-ownership costs as a percentage of household income` > 28;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.124
  Output Similarity: 0.000
  Execution Time: 0.059 seconds

Test 6:
  NLQ: For year 2017, get zipcodes in Georgia where GRAPI is greater than or equal to 30.
  Predicted SQL: SELECT * FROM housing_gross_rent_percent;
  Ground Truth SQL: select substring(housing_gross_rent_percent.zipcode, 7, 10) as zcta, sum(number_of_units*(income_percent_min+income_percent_max)/2)/sum(number_of_units) as `Gross rent percent` 
from housing_gross_rent_percent
where year=2017
group by zipcode
having `Gross rent percent` >= 30;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.149
  Output Similarity: 0.000
  Execution Time: 0.051 seconds

Test 7:
  NLQ: For year 2022, get zipcodes in Georgia where GRAPI is greater than 30.
  Predicted SQL: SELECT * FROM housing_gross_rent_percent;
  Ground Truth SQL: select substring(housing_gross_rent_percent.zipcode, 7, 10) as zcta, sum(number_of_units*(income_percent_min+income_percent_max)/2)/sum(number_of_units) as `Gross rent percent` 
from housing_gross_rent_percent
where year=2022
group by zipcode
having `Gross rent percent` > 30;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.149
  Output Similarity: 0.000
  Execution Time: 0.050 seconds

Test 8:
  NLQ: Select share of each fuel source for heating in year 2022.
  Predicted SQL: SELECT * FROM housing_heating_fuel;
  Ground Truth SQL: select year, (sum(utility_gas)/(sum(total_heating_units)))*100 as 'utility_gas', 
(sum(bottled_tank_or_LP_gas)/(sum(total_heating_units)))*100 as 'bottled_tank_or_LP_gas', 
(sum(electricity)/(sum(total_heating_units)))*100 as 'electricity', 
(sum(fuel_oil_kerosene)/(sum(total_heating_units)))*100 as 'fuel_oil_kerosene', 
(sum(coal_or_coke)/(sum(total_heating_units)))*100 as 'coal_or_coke', 
(sum(wood)/(sum(total_heating_units)))*100 as 'wood', 
(sum(solar_energy)/(sum(total_heating_units)))*100 as 'solar_energy', 
(sum(utility_gas)/(sum(total_heating_units)))*100 as 'utility_gas', 
(sum(no_fuel_used)/(sum(total_heating_units)))*100 as 'no_fuel_used'
from housing_heating_fuel 
where year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.051
  Output Similarity: 0.000
  Execution Time: 0.015 seconds

Test 9:
  NLQ: For the year 2022, select zipcodes in Georgia where Home-ownership costs as a %age of household income is more than 28%
  Predicted SQL: SELECT * FROM household_income_percent_with_mortgage;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, sum(number_of_units*(income_percent_min+income_percent_max)/2)/sum(number_of_units) as `Monthly home-ownership costs as a percentage of household income` from household_income_percent_with_mortgage where year=2022 group by zipcode having `Monthly home-ownership costs as a percentage of household income` >= 30;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.150
  Output Similarity: 0.000
  Execution Time: 0.042 seconds

Test 10:
  NLQ: For each year, get rent and value of house averaged over all zip codes.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select STR_TO_DATE(CONCAT(house_rent_value.year, '-01-01'), '%Y-%m-%d') AS year_date, avg(rent_weighted_average) as rent, avg(house_value_weighted_average) as house_value 
from
(select rent_avg.*, house_value_avg.house_value_weighted_average
from (select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent
group by year, zipcode) as rent_avg, 
(select year, zipcode, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as house_value_weighted_average
from housing_value
group by year, zipcode) as house_value_avg
where rent_avg.year = house_value_avg.year and rent_avg.zipcode = house_value_avg.zipcode) as house_rent_value 
group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.035
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 11:
  NLQ: For each zip code, get rent and value of house averaged over all years.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zip, avg(rent_weighted_average) as rent, avg(house_value_weighted_average) as house_value 
from
(select rent_avg.*, house_value_avg.house_value_weighted_average
from (select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent
group by year, zipcode) as rent_avg, 
(select year, zipcode, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as house_value_weighted_average
from housing_value
group by year, zipcode) as house_value_avg
where rent_avg.year = house_value_avg.year and rent_avg.zipcode = house_value_avg.zipcode) as house_rent_value 
group by zip;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.037
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 12:
  NLQ: For each zipcode, get count of units with and without mortgage in year 2022.
  Predicted SQL: SELECT * FROM housing_mortgage;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, units_with_mortgage, units_without_mortgage
from housing_mortgage where year=2022
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.236
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 13:
  NLQ: Get count of units with and without mortgage averaged over years.
  Predicted SQL: SELECT * FROM housing_mortgage;
  Ground Truth SQL: select year, avg(units_with_mortgage) as 'units_with_mortgage', avg(units_without_mortgage) as 'units_without_mortgage'
from housing_mortgage
group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.192
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 14:
  NLQ: Get count of units with and without mortgage for year 2022.
  Predicted SQL: SELECT * FROM housing_mortgage;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, units_with_mortgage, units_without_mortgage
from housing_mortgage where year=2022
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.236
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 15:
  NLQ: Get average house price for each zip code in a given year.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select substring(housing_value.zipcode, 7, 10) as zcta, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as housing_value_weighted_avg
from housing_value where year={{year}} group by zipcode
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.110
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 16:
  NLQ: For each zip code, get the average rent and maintenance cost for households without mortgage.
  Predicted SQL: SELECT * FROM household_income_percent_without_mortgage;
  Ground Truth SQL: select substring(rent_affordability.zipcode, 7, 10) as zcta, rent_affordability.rent_weighted_avg, maintenance_costs.maintenance_weighted_avg_without_mortgage
from 
(select zipcode, (sum(number_of_units*((income_percent_min+income_percent_max)/2))/sum(number_of_units)) as maintenance_weighted_avg_without_mortgage from household_income_percent_without_mortgage where year=2022 group by zipcode) as maintenance_costs,
(select zipcode, (sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as rent_weighted_avg from housing_rent where year=2022 group by zipcode) as rent_affordability
where maintenance_costs.zipcode = rent_affordability.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.084
  Output Similarity: 0.000
  Execution Time: 0.059 seconds

Test 17:
  NLQ: Get median housing value by zipcode.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: WITH CumulativeUnits AS (
    SELECT
        zipcode,
        house_value_min,
        house_value_max,
        number_of_units,
        SUM(number_of_units) OVER (PARTITION BY zipcode ORDER BY house_value_max) AS cumulative_units
    FROM
        housing_value
),
TotalUnits AS (
    SELECT
        zipcode,
        SUM(number_of_units) AS total_units
    FROM
        housing_value
    GROUP BY
        zipcode
)
SELECT
    substring(t.zipcode, 7, 10) as zcta,
    CASE
        WHEN t.total_units % 2 = 1 THEN
            (SELECT (h.house_value_max + h.house_value_min) / 2
            FROM CumulativeUnits h
            WHERE h.zipcode = t.zipcode AND h.cumulative_units >= t.total_units / 2
            LIMIT 1)
        ELSE
            (SELECT (h.house_value_max + COALESCE((LAG(h.house_value_max) OVER (PARTITION BY h.zipcode ORDER BY h.house_value_max)), 0)) / 2.0
            FROM CumulativeUnits h
            WHERE h.zipcode = t.zipcode AND h.cumulative_units >= t.total_units / 2
            LIMIT 1)
    END AS median
FROM
    TotalUnits t;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.042
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 18:
  NLQ: For year 2022 and for each zipcode, get average rent value and house price.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select rent_avg.year, rent_avg.zipcode, rent_avg.rent_weighted_average, house_value_avg.house_value_weighted_average
from (select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent
group by year, zipcode) as rent_avg, 
(select year, zipcode, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as house_value_weighted_average
from housing_value
group by year, zipcode) as house_value_avg
where rent_avg.year = house_value_avg.year and rent_avg.zipcode = house_value_avg.zipcode and rent_avg.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.042
  Output Similarity: 0.000
  Execution Time: 0.069 seconds

Test 19:
  NLQ: For each zipcode, get average rent value and house price.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zip, avg(rent_weighted_average) as rent, avg(house_value_weighted_average) as house_value 
from
(select rent_avg.*, house_value_avg.house_value_weighted_average
from (select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent
group by year, zipcode) as rent_avg, 
(select year, zipcode, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as house_value_weighted_average
from housing_value
group by year, zipcode) as house_value_avg
where rent_avg.year = house_value_avg.year and rent_avg.zipcode = house_value_avg.zipcode) as house_rent_value 
group by zip;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.037
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 20:
  NLQ: Get total housing units in 2022 grouped by zipcode.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, sum(total_units) as total_units from
(select zipcode, sum(number_of_units) as total_units from housing_value where year=2022 group by zipcode union all select zipcode, sum(number_of_units) as total_units from housing_rent where year=2022 group by zipcode) h group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.085
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 21:
  NLQ: For each zipcode, count houses built in or after 2020.
  Predicted SQL: SELECT * FROM housing_year_built;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, number_of_units from housing_year_built where year_built_min = 2020;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.291
  Output Similarity: 0.000
  Execution Time: 0.012 seconds

Test 22:
  NLQ: Get percentage of zipcodes having GRAPI greater than 28% in year 2022
  Predicted SQL: SELECT * FROM housing_gross_rent_percent;
  Ground Truth SQL: SELECT 100*grapi_zipcodes/total as `Zipcodes with GRAPI greater than 28%` FROM
(SELECT 
    COUNT(h.zipcode) as grapi_zipcodes
FROM 
    (SELECT DISTINCT zipcode, SUM(a.number_of_units*(a.income_percent_max+a.income_percent_min)/2)/SUM(a.number_of_units) AS smocapi 
    FROM housing_gross_rent_percent AS a 
    WHERE year = 2022 
    GROUP BY zipcode 
    HAVING smocapi >= 30) AS h) as t1,
(SELECT COUNT(DISTINCT zipcode) as total
    FROM housing_gross_rent_percent 
    WHERE year = 2022) as t2;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.089
  Output Similarity: 0.000
  Execution Time: 0.051 seconds

Test 23:
  NLQ: Get percentage of zipcodes having SMOCAPI greater than 30% in year 2022.
  Predicted SQL: SELECT * FROM household_income_percent_with_mortgage;
  Ground Truth SQL: SELECT 100*smocapi_zipcodes/total as `Zipcodes with SMOCAPI greater than 28%` FROM
(SELECT 
    COUNT(h.zipcode) as smocapi_zipcodes
FROM 
    (SELECT DISTINCT zipcode, SUM(a.number_of_units*(a.income_percent_max+a.income_percent_min)/2)/SUM(a.number_of_units) AS smocapi 
    FROM household_income_percent_with_mortgage AS a 
    WHERE year = 2022 
    GROUP BY zipcode 
    HAVING smocapi >= 30) AS h) as t1,
(SELECT COUNT(DISTINCT zipcode) as total
    FROM household_income_percent_with_mortgage 
    WHERE year = 2022) as t2;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.108
  Output Similarity: 0.000
  Execution Time: 0.042 seconds

Test 24:
  NLQ: Get average population of males and females by year in Georgia
  Predicted SQL: SELECT * FROM demographic_basics;
  Ground Truth SQL: select year, avg(total_population_male), avg(total_population_female) from demographic_basics group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.296
  Output Similarity: 0.000
  Execution Time: 0.015 seconds

Test 25:
  NLQ: For year 2022, get gender ratio between males and females for each zipcode in Georgia.
  Predicted SQL: SELECT * FROM demographic_basics;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, avg(total_population_male/total_population_female) from demographic_basics where year=2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.213
  Output Similarity: 0.000
  Execution Time: 0.015 seconds

Test 26:
  NLQ: For each year after 2016, get average count of each ethnicity in Georgia.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select year, avg(white) as 'white', avg(black) as 'black', avg(asian) as 'asian', avg(american_indian_and_alaska_native) as 'american_indian_and_alaska_native', 
avg(native_hawaiian_and_other_pacific_islander) as 'native_hawaiian_and_other_pacific_islander', avg(hispanic_or_latino) as 'hispanic_or_latino' 
from demographic_race where year > 2016 group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.083
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 27:
  NLQ: For year 2022, get average count of each ethnicity grouped by zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, avg(white), avg(black), avg(asian), avg(american_indian_and_alaska_native), avg(native_hawaiian_and_other_pacific_islander) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.135
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 28:
  NLQ: For year 2022, get percentage of American Indian and Alaskan Natives with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(american_indian_and_alaska_native)/avg(race_total_population) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.183
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 29:
  NLQ: For year 2022, get percentage of Asians with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(asian)/avg(race_total_population) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.220
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 30:
  NLQ: For year 2022, get percentage of Blacks with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(black)/avg(race_total_population) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.220
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 31:
  NLQ: For year 2022, get percentage of Hispanics/Latinos with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(hispanic_or_latino)/avg(hispanic_or_latino_total) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.197
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 32:
  NLQ: For year 2022, get percentage of Native Hawaiian and other Pacific Inlander with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(native_hawaiian_and_other_pacific_islander)/avg(race_total_population) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.174
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 33:
  NLQ: For year 2022, get percentage of Whites with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(white)/avg(race_total_population) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.220
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 34:
  NLQ: For all years after 2016, for each zipcode get percentage of marginalized communities (black, asian, american indian & alaskan native, native hawaiian & pacific inlander) and average SMOCAPI.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(demographic_race.zipcode,7,10) as zcta, 100*(avg(black) + avg(asian) + avg(american_indian_and_alaska_native) + avg(native_hawaiian_and_other_pacific_islander))/avg(race_total_population) as 'Percent Marginalized Communities', sum(number_of_units*(income_percent_max+income_percent_min)/2)/sum(number_of_units) as smocapi
from demographic_race join household_income_percent_with_mortgage on demographic_race.zipcode=household_income_percent_with_mortgage.zipcode where demographic_race.year>2016 and household_income_percent_with_mortgage.year>2016
group by demographic_race.zipcode
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.050
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 35:
  NLQ: For each zipcode in Atlanta, get change in percentage of those travelling in car alone between year 2019 and 2022
  Predicted SQL: SELECT * FROM economic_commute_to_work;
  Ground Truth SQL: SELECT substring(economic_commute_to_work.zipcode, 7, 10) as zip, ((car_alone/total_workers)*100 - commute_old.public_transport_percent) as commute_change
FROM economic_commute_to_work 
join (select zipcode, (car_alone/total_workers)*100 as public_transport_percent
    from economic_commute_to_work where year=2019) as commute_old 
on commute_old.zipcode=economic_commute_to_work.zipcode
where economic_commute_to_work.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.092
  Output Similarity: 0.000
  Execution Time: 0.014 seconds

Test 36:
  NLQ: For each zipcode in Georgia, give the change in mean commute time between 2017 and 2022
  Predicted SQL: SELECT * FROM economic_commute_to_work;
  Ground Truth SQL: SELECT substring(economic_commute_to_work.zipcode, 7, 10) as zip, mean_travel_time - commute_old.mean_time as commute_change
FROM economic_commute_to_work 
join (select zipcode, mean_travel_time as mean_time
    from economic_commute_to_work where year=2017) as commute_old 
on commute_old.zipcode=economic_commute_to_work.zipcode
where economic_commute_to_work.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.104
  Output Similarity: 0.000
  Execution Time: 0.013 seconds

Test 37:
  NLQ: For each zipcode in Atlanta, get change in percentage of those working from home between year 2019 and 2022
  Predicted SQL: SELECT * FROM economic_commute_to_work;
  Ground Truth SQL: SELECT substring(economic_commute_to_work.zipcode, 7, 10) as zip, ((work_from_home/total_workers)*100 - commute_old.public_transport_percent) as work_from_home_change
FROM economic_commute_to_work 
join (select zipcode, (work_from_home/total_workers)*100 as public_transport_percent
    from economic_commute_to_work where year=2019) as commute_old 
on commute_old.zipcode=economic_commute_to_work.zipcode
where economic_commute_to_work.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.088
  Output Similarity: 0.000
  Execution Time: 0.014 seconds

Test 38:
  NLQ: For year 2022, get percentage of each commute type when commuting to work.
  Predicted SQL: SELECT * FROM economic_commute_to_work;
  Ground Truth SQL: select year, (sum(car_alone)/sum(total_workers))*100 as 'car_alone', (sum(car_pool)/sum(total_workers))*100 as 'car_pool', (sum(public_transport)/sum(total_workers))*100 as 'public_transport', (sum(walk)/sum(total_workers))*100 as 'walk', (sum(work_from_home)/sum(total_workers))*100 as 'work_from_home' 
from economic_commute_to_work
where year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.111
  Output Similarity: 0.000
  Execution Time: 0.014 seconds

Test 39:
  NLQ: Get median and mean household income for each year.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: SELECT year, avg(median_household_income) as `Median household income`, avg(mean_household_income) as `Mean household income` FROM economic_income_and_benefits group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.241
  Output Similarity: 0.000
  Execution Time: 0.010 seconds

Test 40:
  NLQ: Get percentage of households with and without mortgage for each year.
  Predicted SQL: SELECT * FROM housing_mortgage;
  Ground Truth SQL: select year, avg(units_with_mortgage) as `Units with mortgage`, avg(units_without_mortgage) as `Units without mortgage` from housing_mortgage group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.192
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 41:
  NLQ: For each zipcode, get mean commute time and average housing value.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: select substring(housing_affordability.zipcode, 7, 10) as zcta, housing_affordability.housing_value_weighted_avg, mean_commute.mean_time
from 
(select zipcode, avg(mean_travel_time) as mean_time from economic_commute_to_work where year=2022 group by zipcode) as mean_commute, 
(select zipcode, (sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as housing_value_weighted_avg from housing_value where year=2022 group by zipcode) as housing_affordability
where mean_commute.zipcode = housing_affordability.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.076
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 42:
  NLQ: Get mean commute time by zipcode in the year 2022.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, avg(mean_travel_time) from economic_commute_to_work where year=2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.228
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 43:
  NLQ: Get average housing rent and mean household income across all zipcodes for the year 2022.
  Predicted SQL: SELECT * FROM housing_rent;
  Ground Truth SQL: select rent_avg.*, economic_income_and_benefits.mean_household_income
from (select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent
group by year, zipcode) as rent_avg, economic_income_and_benefits
where rent_avg.year = economic_income_and_benefits.year and rent_avg.zipcode = economic_income_and_benefits.zipcode and rent_avg.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.060
  Output Similarity: 0.000
  Execution Time: 0.061 seconds

Test 44:
  NLQ: For each zipcode in year 2022, get median household income.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: SELECT substring(zipcode, 7, 10) as zcta, avg(median_household_income), avg(mean_household_income) FROM economic_income_and_benefits WHERE year=2022 group by zcta;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.258
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 45:
  NLQ: For each zipcode, get change in averaged median household income from 2017 to 2022.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: SELECT substring(economic_income_and_benefits.zipcode, 7, 10) as zcta, avg(median_household_income) - median_2017.median_income FROM economic_income_and_benefits join
(SELECT zipcode, avg(median_household_income) as median_income FROM economic_income_and_benefits where year=2016 group by zipcode) median_2017
on economic_income_and_benefits.zipcode=median_2017.zipcode
WHERE year=2022 group by economic_income_and_benefits.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.097
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 46:
  NLQ: For each zipcode of Georgia, get median and mean household income over all the years.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: SELECT substring(zipcode, 7, 10) as zcta, avg(median_household_income), avg(mean_household_income) FROM economic_income_and_benefits group by zcta;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.286
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 47:
  NLQ: For each zipcode, get percentage of units with mortgage and median household income.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: select m.zipcode, avg(units_with_mortgage)/avg(units_with_mortgage+units_without_mortgage), avg(median_household_income)
from housing_mortgage as m join economic_income_and_benefits as e on m.zipcode=e.zipcode
group by m.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.183
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 48:
  NLQ: For each zipcode in the year 2022, get average housing value and median household income.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: SELECT
  `source`.`zipcode` AS `zipcode`,
  `source`.`house_value_weighted_average` AS `house_value_weighted_average`,
  `Economic Income And Benefits`.`median_household_income` AS `Economic Income And Benefits__median_household_income`
FROM
  (
    select
      zipcode,
      cast(
        (
          sum(
            number_of_units * ((house_value_min + house_value_max) / 2)
          ) / sum(number_of_units)
        ) as decimal(8, 2)
      ) as house_value_weighted_average
    from
      housing_value
    where
      year = 2022
    group by
      zipcode
  ) AS `source`
 
LEFT JOIN `economic_income_and_benefits` AS `Economic Income And Benefits` ON `source`.`zipcode` = `Economic Income And Benefits`.`zipcode`
WHERE
  `Economic Income And Benefits`.`year` = 2022
LIMIT
  1048575
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.062
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 49:
  NLQ: For each zipcode of Georgia, find the change in percentage of population with no health insurance from year 2017 to 2022.
  Predicted SQL: SELECT * FROM economic_health_insurance;
  Ground Truth SQL: SELECT substring(economic_health_insurance.zipcode, 7, 10) as zip, 100*no_health_insurance/total_population - avg_no_health_insurance.a as change_from_average
FROM economic_health_insurance 
join (select zipcode, avg(100*no_health_insurance/total_population) as a 
    from economic_health_insurance where year=2017 group by zipcode) as avg_no_health_insurance 
on avg_no_health_insurance.zipcode=economic_health_insurance.zipcode
where economic_health_insurance.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.086
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 50:
  NLQ: For each zipcode in year 2022, get percentage of population with no health insurance and average house rent.
  Predicted SQL: SELECT * FROM economic_health_insurance;
  Ground Truth SQL: select health_ins.*, rent_avg.rent_weighted_average from 
(SELECT year, zipcode, 100*(no_health_insurance/total_population) as no_health_insurance
FROM economic_health_insurance 
where economic_health_insurance.year=2022) as health_ins,
(select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent group by year, zipcode) as rent_avg
where rent_avg.zipcode = health_ins.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.083
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 51:
  NLQ: For each zipcode in year 2022, get percentage of population with no health insurance and average housing price.
  Predicted SQL: SELECT * FROM economic_health_insurance;
  Ground Truth SQL: select health_ins.*, housing_val.housing_value_weighted_avg from 
(SELECT year, zipcode, 100*(no_health_insurance/total_population) as no_health_insurance
FROM economic_health_insurance 
where economic_health_insurance.year=2022) as health_ins,
(select zipcode, (sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as housing_value_weighted_avg
from housing_value where year=2022 group by zipcode) as housing_val
where housing_val.zipcode = health_ins.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.082
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 52:
  NLQ: For each zipcode in Georgia, get the change in percentage of population commuting via public transport from year 2017 to 2022.
  Predicted SQL: SELECT * FROM economic_commute_to_work;
  Ground Truth SQL: SELECT substring(economic_commute_to_work.zipcode, 7, 10) as zip, ((public_transport/total_workers)*100 - commute_old.public_transport_percent) as commute_change
FROM economic_commute_to_work 
join (select zipcode, (public_transport/total_workers)*100 as public_transport_percent
    from economic_commute_to_work where year=2017) as commute_old 
on commute_old.zipcode=economic_commute_to_work.zipcode
where economic_commute_to_work.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.089
  Output Similarity: 0.000
  Execution Time: 0.014 seconds

Test 53:
  NLQ: For each zipcode in Georgia, get the count of non-US citizens and foreign born population
  Predicted SQL: SELECT * FROM social_citizenship_status;
  Ground Truth SQL: select substring(zipcode,7,10) as zcta, foreign_born_population, not_a_us_citizen from social_citizenship_status where year=2022
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.297
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 54:
  NLQ: Get the average of each ethnic group (black, white, asian) by year.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: SELECT year, avg(black), avg(white), avg(asian) FROM demographic_race group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.357
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 55:
  NLQ: Get the percentage of types of education attained by population aged 25 and above for each year.
  Predicted SQL: SELECT * FROM social_education_attainment;
  Ground Truth SQL: select year, (sum(less_than_9th_grade)/sum(population_25_years_and_over))*100 as 'less_than_9th_grade', (sum(9th_to_12th_grade_no_diploma)/sum(population_25_years_and_over))*100 as '9th_to_12th', (sum(high_school_graduate)/sum(population_25_years_and_over))*100 as 'high_school_graduate', (sum(some_college_no_degree)/sum(population_25_years_and_over))*100 as 'some_college_no_degree', (sum(associate_degree)/sum(population_25_years_and_over))*100 as 'associate_degree', (sum(bachelors_degree)/sum(population_25_years_and_over))*100 as 'bachelors_degree', (sum(graduate_or_professional_degree)/sum(population_25_years_and_over))*100 as 'graduate_or_professional_degree' 
from social_education_attainment
group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.059
  Output Similarity: 0.000
  Execution Time: 0.016 seconds

Test 56:
  NLQ: In year 2022, for each zipcode in Georgia, get the percentage of population with associate and bachelors degree or higher and average housing price.
  Predicted SQL: SELECT * FROM social_education_attainment;
  Ground Truth SQL: select substring(h.zipcode, 7, 10) as zcta, ((associate_degree+bachelors_degree_or_higher)/population_25_years_and_over)*100 as education_attaimnemt_percent, h.housing_value_weighted_avg
from social_education_attainment join 
(select zipcode, (sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as housing_value_weighted_avg
from housing_value where year=2022 group by zipcode) as h on h.zipcode=social_education_attainment.zipcode
where year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.088
  Output Similarity: 0.000
  Execution Time: 0.015 seconds

Test 57:
  NLQ: For all years after 2016, for each zipcode get average housing  price and percentage of houses having broadband subscription.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select h.zipcode, sum(number_of_units*(house_value_min+house_value_max)/2)/sum(number_of_units), avg(with_a_computer)/avg(total_households), avg(with_broadband_internet_subscription)/avg(total_households)
from housing_value as h join social_computer_internet_usage as s on h.zipcode=s.zipcode
where h.year > 2016 and s.year > 2016
group by h.zipcode;
-- select * from social_computer_internet_usage where year>2016
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.068
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 58:
  NLQ: For all years after 2016, for each zipcode get average housing  rent and percentage of houses having broadband subscription.
  Predicted SQL: SELECT * FROM housing_rent;
  Ground Truth SQL: select h.zipcode, sum(number_of_units*(rent_value_min+rent_value_max)/2)/sum(number_of_units), avg(with_a_computer)/avg(total_households), avg(with_broadband_internet_subscription)/avg(total_households)
from housing_rent as h join social_computer_internet_usage as s on h.zipcode=s.zipcode
where h.year > 2016 and s.year > 2016
group by h.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.078
  Output Similarity: 0.000
  Execution Time: 0.061 seconds

Test 59:
  NLQ: For all years after 2016, for each zipcode, get percentage of households with a computer and percentage of housholds with broadband subscription.
  Predicted SQL: SELECT * FROM social_computer_internet_usage;
  Ground Truth SQL: select year, (sum(with_a_computer)/sum(total_households))*100 as 'with_computer', (sum(with_broadband_internet_subscription)/sum(total_households))*100 as 'broadband_connection' from social_computer_internet_usage where year>=2017 group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.184
  Output Similarity: 0.000
  Execution Time: 0.010 seconds

Test 60:
  NLQ: Give total crimes occurred in Atlanta on each day of the week
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(`atlanta_crime_data`.`Crime_Date`) AS `Crime_Date`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  DAYOFWEEK(`atlanta_crime_data`.`Crime_Date`)
ORDER BY
  DAYOFWEEK(`atlanta_crime_data`.`Crime_Date`) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.142
  Output Similarity: 0.000
  Execution Time: 0.897 seconds

Test 61:
  NLQ: Give total crimes occurred in Atlanta during each month of the year
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
    MONTH(Crime_Date) AS Month,
    COUNT(*) AS Crime_Count
FROM
    atlanta_crime_data
GROUP BY
    MONTH(Crime_Date)
ORDER BY
    MONTH(Crime_Date);
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.241
  Output Similarity: 0.000
  Execution Time: 0.898 seconds

Test 62:
  NLQ: Give total crimes occurred in Atlanta at each hour of the day
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  CASE
    WHEN HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s')) = 0 THEN 24
    ELSE HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s'))
  END AS `Hour`,
  COUNT(*) AS `Count`
FROM
  `atlanta_crime_data`
GROUP BY
  `Hour`
ORDER BY
  `Hour` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.123
  Output Similarity: 0.000
  Execution Time: 0.898 seconds

Test 63:
  NLQ: Give total count of crimes in Atlanta grouped by week since January 2009
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`atlanta_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) AS `Crime_Date`,
  count(distinct `atlanta_crime_data`.`Report_#`) AS `count`
FROM
  `atlanta_crime_data`
WHERE
  `atlanta_crime_data`.`Crime_Date` >= convert_tz(
    '2009-01-05 00:00:00.000',
    'America/New_York',
    @@session.time_zone
  )
GROUP BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`atlanta_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`atlanta_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.102
  Output Similarity: 0.000
  Execution Time: 0.899 seconds

Test 64:
  NLQ: Give total crimes occurred in LA on each day of the week
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(`la_crime_data`.`Crime_Date`) AS `Crime_Date`,
  COUNT(*) AS `count`
FROM
  `la_crime_data`
GROUP BY
  DAYOFWEEK(`la_crime_data`.`Crime_Date`)
ORDER BY
  DAYOFWEEK(`la_crime_data`.`Crime_Date`) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.131
  Output Similarity: 0.000
  Execution Time: 2.759 seconds

Test 65:
  NLQ: Give total crimes occurred in LA during each month of the year
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
    MONTH(Crime_Date) AS Month,
    COUNT(*) AS Crime_Count
FROM
    la_crime_data
GROUP BY
    MONTH(Crime_Date)
ORDER BY
    MONTH(Crime_Date);
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.212
  Output Similarity: 0.000
  Execution Time: 2.758 seconds

Test 66:
  NLQ: Give total crimes occurred in LA at each hour of the day
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  FLOOR(`la_crime_data`.`Crime_Time` / 100) + 1 AS `Hour`,
  COUNT(*) AS `Count`
FROM
  `la_crime_data`
GROUP BY
  `Hour`
ORDER BY
  `Hour` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.193
  Output Similarity: 0.000
  Execution Time: 2.758 seconds

Test 67:
  NLQ: Give total count of crimes in LA grouped by week
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(YEARWEEK(`la_crime_data`.`Crime_Date`), ' Sunday'),
    '%X%V %W'
  ) AS `Crime_Date`,
  count(distinct `la_crime_data`.`Report_#`) AS `count`
FROM
  `la_crime_data`
GROUP BY
  STR_TO_DATE(
    CONCAT(YEARWEEK(`la_crime_data`.`Crime_Date`), ' Sunday'),
    '%X%V %W'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(YEARWEEK(`la_crime_data`.`Crime_Date`), ' Sunday'),
    '%X%V %W'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.070
  Output Similarity: 0.000
  Execution Time: 2.757 seconds

Test 68:
  NLQ: Give total crimes occurred in New York on each day of the week
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(`nyc_crime_data`.`Crime_Date`) AS `Crime_Date`,
  COUNT(*) AS `count`
FROM
  `nyc_crime_data`
GROUP BY
  DAYOFWEEK(`nyc_crime_data`.`Crime_Date`)
ORDER BY
  DAYOFWEEK(`nyc_crime_data`.`Crime_Date`) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.133
  Output Similarity: 0.000
  Execution Time: 1.290 seconds

Test 69:
  NLQ: Give total crimes occurred in New York during each month of the year
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
    MONTH(Crime_Date) AS Month,
    COUNT(*) AS Crime_Count
FROM
    nyc_crime_data
GROUP BY
    MONTH(Crime_Date)
ORDER BY
    MONTH(Crime_Date);
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.218
  Output Similarity: 0.000
  Execution Time: 1.291 seconds

Test 70:
  NLQ: Give total crimes occurred in New York at each hour of the day
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  HOUR(`nyc_crime_data`.`Crime_Time`) + 1 AS `Hour`,
  COUNT(*) AS `Count`
FROM
  `nyc_crime_data`
GROUP BY
  `Hour`
ORDER BY
  `Hour` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.207
  Output Similarity: 0.000
  Execution Time: 1.292 seconds

Test 71:
  NLQ: Give total count of crimes in New York grouped by week since January 2023
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`nyc_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) AS `Crime_Date`,
  count(distinct `nyc_crime_data`.`Report_#`) AS `count`
FROM
  `nyc_crime_data`
WHERE
  `nyc_crime_data`.`Crime_Date` >= convert_tz(
    '2023-01-02 00:00:00.000',
    'America/New_York',
    @@session.time_zone
  )
GROUP BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`nyc_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`nyc_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.094
  Output Similarity: 0.000
  Execution Time: 1.293 seconds

Test 72:
  NLQ: Give total crimes occurred in Philly on each day of the week
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(`philly_crime_data`.`Crime_Date`) AS `Crime_Date`,
  COUNT(*) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  DAYOFWEEK(`philly_crime_data`.`Crime_Date`)
ORDER BY
  DAYOFWEEK(`philly_crime_data`.`Crime_Date`) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.140
  Output Similarity: 0.000
  Execution Time: 2.324 seconds

Test 73:
  NLQ: Give total crimes occurred in Philly during each month of the year
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
    MONTH(Crime_Date) AS Month,
    COUNT(*) AS Crime_Count
FROM
    philly_crime_data
GROUP BY
    MONTH(Crime_Date)
ORDER BY
    MONTH(Crime_Date);
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.235
  Output Similarity: 0.000
  Execution Time: 2.324 seconds

Test 74:
  NLQ: Give total crimes occurred in Philly at each hour of the day
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  HOUR(`philly_crime_data`.`Crime_Time`) + 1 AS `Hour`,
  COUNT(*) AS `Count`
FROM
  `philly_crime_data`
GROUP BY
  `Hour`
ORDER BY
  `Hour` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.220
  Output Similarity: 0.000
  Execution Time: 2.327 seconds

Test 75:
  NLQ: Give total count of crimes in Philly grouped by week
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`philly_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) AS `Crime_Date`,
  count(distinct `philly_crime_data`.`Crime_ID`) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`philly_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`philly_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.075
  Output Similarity: 0.000
  Execution Time: 2.326 seconds

Test 76:
  NLQ: Give the amount of crimes in each area of Atlanta
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  `atlanta_crime_data`.`Area_Name` AS `Area_Name`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  `atlanta_crime_data`.`Area_Name`
ORDER BY
  `atlanta_crime_data`.`Area_Name` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.169
  Output Similarity: 0.000
  Execution Time: 0.898 seconds

Test 77:
  NLQ: For each area of Atlanta give the total crime count, last reported date of any crime and the type of crime, most common crime type and weekly increase in crimes by percentage.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
    c.Area_Name,
    c.Cumulative_Crime_Count,
    c.Latest_Crime_Date,
    c.Latest_Crime_Type,
    IFNULL(mct.Most_Common_Crime_Type, 'Unknown') AS Most_Common_Crime_Type,
    IFNULL((c.Crime_Change / c.Cumulative_Crime_Count) * 100, 0) AS Crime_Change_Last_Week_Proportion
FROM (
    SELECT
        Area_Name,
        COUNT(*) AS Cumulative_Crime_Count,
        latest_date AS Latest_Crime_Date,
        SUBSTRING_INDEX(GROUP_CONCAT(Crime_Type ORDER BY Crime_Date DESC), ',', 1) AS Latest_Crime_Type,
        SUM(CASE WHEN Crime_Date >= latest_date - INTERVAL 1 WEEK THEN 1 ELSE 0 END) AS Crime_Change
    FROM
        atlanta_crime_data
    CROSS JOIN (SELECT MAX(Crime_Date) AS latest_date FROM atlanta_crime_data) AS max_date
    GROUP BY
        Area_Name, latest_date
) c
LEFT JOIN (
    SELECT
        Area_Name,
        Most_Common_Crime_Type
    FROM (
        SELECT
            Area_Name,
            Crime_Type AS Most_Common_Crime_Type,
            ROW_NUMBER() OVER(PARTITION BY Area_Name ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            atlanta_crime_data
        GROUP BY
            Area_Name, Crime_Type
    ) ranked_crimes
    WHERE
        crime_rank = 1
) mct ON c.Area_Name = mct.Area_Name
ORDER BY
    c.Area_Name ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.034
  Output Similarity: 0.000
  Execution Time: 0.899 seconds

Test 78:
  NLQ: Give the amount of crimes in each area of LA
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  `la_crime_data`.`Area_Name` AS `Area_Name`,
  COUNT(*) AS `count`
FROM
  `la_crime_data`
GROUP BY
  `la_crime_data`.`Area_Name`
ORDER BY
  `la_crime_data`.`Area_Name` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.160
  Output Similarity: 0.000
  Execution Time: 2.761 seconds

Test 79:
  NLQ: For each area of LA give the total crime count, last reported date of any crime and the type of crime, most common crime type and weekly increase in crimes by percentage.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
    c.Area_Name,
    c.Cumulative_Crime_Count,
    c.Latest_Crime_Date,
    c.Latest_Crime_Type,
    mct.Most_Common_Crime_Type,
    IFNULL((c.Crime_Change / c.Cumulative_Crime_Count) * 100, 0) AS Crime_Change_Last_Week_Proportion
FROM (
    SELECT
        Area_Name,
        COUNT(*) AS Cumulative_Crime_Count,
        MAX(Crime_Date) AS Latest_Crime_Date,
        SUBSTRING_INDEX(GROUP_CONCAT(Crime_Type ORDER BY Crime_Date DESC), ',', 1) AS Latest_Crime_Type,
        SUM(CASE WHEN Crime_Date >= CURDATE() - INTERVAL 1 WEEK THEN 1 ELSE 0 END) AS Crime_Change
    FROM
        la_crime_data
    GROUP BY
        Area_Name
) c
LEFT JOIN (
    SELECT
        Area_Name,
        Most_Common_Crime_Type
    FROM (
        SELECT
            Area_Name,
            Crime_Type AS Most_Common_Crime_Type,
            ROW_NUMBER() OVER(PARTITION BY Area_Name ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            la_crime_data
        GROUP BY
            Area_Name, Crime_Type
    ) ranked_crimes
    WHERE
        crime_rank = 1
) mct ON c.Area_Name = mct.Area_Name
ORDER BY
    c.Area_Name ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.034
  Output Similarity: 0.000
  Execution Time: 2.758 seconds

Test 80:
  NLQ: Give the amount of crimes in each area of New York
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  `nyc_crime_data`.`Area_Name` AS `Area_Name`,
  COUNT(*) AS `count`
FROM
  `nyc_crime_data`
GROUP BY
  `nyc_crime_data`.`Area_Name`
ORDER BY
  `nyc_crime_data`.`Area_Name` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.162
  Output Similarity: 0.000
  Execution Time: 1.295 seconds

Test 81:
  NLQ: For each area of New York give the total crime count, last reported date of any crime and the type of crime, most common crime type and weekly increase in crimes by percentage.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
    c.Area_Name,
    c.Cumulative_Crime_Count,
    c.Latest_Crime_Date,
    c.Latest_Crime_Type,
    mct.Most_Common_Crime_Type,
    IFNULL((c.Crime_Change / c.Cumulative_Crime_Count) * 100, 0) AS Crime_Change_Last_Week_Proportion
FROM (
    SELECT
        Area_Name,
        COUNT(*) AS Cumulative_Crime_Count,
        MAX(Crime_Date) AS Latest_Crime_Date,
        SUBSTRING_INDEX(GROUP_CONCAT(Crime_Type ORDER BY Crime_Date DESC), ',', 1) AS Latest_Crime_Type,
        SUM(CASE WHEN Crime_Date >= (SELECT MAX(Crime_Date) FROM nyc_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) AS Crime_Change
    FROM
        nyc_crime_data
    GROUP BY
        Area_Name
) c
LEFT JOIN (
    SELECT
        Area_Name,
        Most_Common_Crime_Type
    FROM (
        SELECT
            Area_Name,
            Crime_Type AS Most_Common_Crime_Type,
            ROW_NUMBER() OVER(PARTITION BY Area_Name ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            nyc_crime_data
        GROUP BY
            Area_Name, Crime_Type
    ) ranked_crimes
    WHERE
        crime_rank = 1
) mct ON c.Area_Name = mct.Area_Name
ORDER BY
    c.Area_Name ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.034
  Output Similarity: 0.000
  Execution Time: 1.299 seconds

Test 82:
  NLQ: Give the amount of crimes in each area of Philly
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10 AS `Area_#`,
  COUNT(*) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10
ORDER BY
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10 ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.135
  Output Similarity: 0.000
  Execution Time: 2.321 seconds

Test 83:
  NLQ: For each area of Philly give the total crime count, last reported date of any crime and the type of crime, most common crime type and weekly increase in crimes by percentage.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
    CONCAT(FLOOR(c.`Area_#` / 10) * 10, ' - ', FLOOR(c.`Area_#` / 10) * 10 + 9) AS Area_Num_Range,
    SUM(c.Cumulative_Crime_Count) AS Cumulative_Crime_Count,
    MAX(c.Latest_Crime_Date) AS Latest_Crime_Date,
    MAX(c.Latest_Crime_Type) AS Latest_Crime_Type,
    MAX(mct.Most_Common_Crime_Type) AS Most_Common_Crime_Type,
    IFNULL((SUM(c.Crime_Change) / SUM(c.Cumulative_Crime_Count)) * 100, 0) AS Crime_Change_Last_Week_Proportion
FROM (
    SELECT
        `Area_#`,
        COUNT(*) AS Cumulative_Crime_Count,
        MAX(Crime_Date) AS Latest_Crime_Date,
        SUBSTRING_INDEX(GROUP_CONCAT(Crime_Type ORDER BY Crime_Date DESC), ',', 1) AS Latest_Crime_Type,
        SUM(CASE WHEN Crime_Date >= (SELECT MAX(Crime_Date) FROM philly_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) AS Crime_Change
    FROM
        philly_crime_data
    GROUP BY
        `Area_#`
) c
LEFT JOIN (
    SELECT
        `Area_#`,
        Most_Common_Crime_Type
    FROM (
        SELECT
            `Area_#`,
            Crime_Type AS Most_Common_Crime_Type,
            ROW_NUMBER() OVER(PARTITION BY `Area_#` ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            philly_crime_data
        GROUP BY
            `Area_#`, Crime_Type
    ) ranked_crimes
    WHERE
        crime_rank = 1
) mct ON c.`Area_#` = mct.`Area_#`
GROUP BY
    CONCAT(FLOOR(c.`Area_#` / 10) * 10, ' - ', FLOOR(c.`Area_#` / 10) * 10 + 9)
ORDER BY
    CONCAT(FLOOR(c.`Area_#` / 10) * 10, ' - ', FLOOR(c.`Area_#` / 10) * 10 + 9);
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.028
  Output Similarity: 0.000
  Execution Time: 2.322 seconds

Test 84:
  NLQ: For each coordinate in latitude and longitude of Atlanta spaced by 0.01 degrees, give the most common crime type and its count
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  Latitude,
  Longitude,
  Most_Common_Crime_Type,
  count
FROM (
  SELECT
    (
      FLOOR(((`atlanta_crime_data`.`Latitude` - 33.64) / 0.01)) * 0.01
    ) + 33.64 AS Latitude,
    (
      FLOOR(((`atlanta_crime_data`.`Longitude` - -84.55) / 0.01)) * 0.01
    ) + -84.55 AS Longitude,
    Crime_Type AS Most_Common_Crime_Type,
    COUNT(*) AS count,
    ROW_NUMBER() OVER(PARTITION BY
      (
        FLOOR(((`atlanta_crime_data`.`Latitude` - 33.64) / 0.01)) * 0.01
      ) + 33.64,
      (
        FLOOR(((`atlanta_crime_data`.`Longitude` - -84.55) / 0.01)) * 0.01
      ) + -84.55
    ORDER BY COUNT(*) DESC
    ) AS crime_rank
  FROM
    `atlanta_crime_data`
  GROUP BY
    Latitude,
    Longitude,
    Crime_Type
) AS ranked_crimes
WHERE
  crime_rank = 1
ORDER BY
  Latitude ASC,
  Longitude ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.050
  Output Similarity: 0.000
  Execution Time: 0.896 seconds

Test 85:
  NLQ: For each coordinate in latitude and longitude of Atlanta spaced by 0.01 degrees, give the total crime count.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  (
    FLOOR(((`atlanta_crime_data`.`Latitude` - 33.64) / 0.01)) * 0.01
  ) + 33.64 AS `Latitude`,
  (
    FLOOR(((`atlanta_crime_data`.`Longitude` - -84.55) / 0.01)) * 0.01
  ) + -84.55 AS `Longitude`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  (
    FLOOR(((`atlanta_crime_data`.`Latitude` - 33.64) / 0.01)) * 0.01
  ) + 33.64,
  (
    FLOOR(((`atlanta_crime_data`.`Longitude` - -84.55) / 0.01)) * 0.01
  ) + -84.55
ORDER BY
  (
    FLOOR(((`atlanta_crime_data`.`Latitude` - 33.64) / 0.01)) * 0.01
  ) + 33.64 ASC,
  (
    FLOOR(((`atlanta_crime_data`.`Longitude` - -84.55) / 0.01)) * 0.01
  ) + -84.55 ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.055
  Output Similarity: 0.000
  Execution Time: 0.898 seconds

Test 86:
  NLQ: For each coordinate in latitude and longitude of LA spaced by 0.01 degrees, give the total crime count.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  FLOOR((`la_crime_data`.`Latitude` / 0.01)) * 0.01 AS `Latitude`,
  (
    FLOOR(((`la_crime_data`.`Longitude` - -118.66) / 0.01)) * 0.01
  ) + -118.66 AS `Longitude`,
  COUNT(*) AS `count`
FROM
  `la_crime_data`
GROUP BY
  FLOOR((`la_crime_data`.`Latitude` / 0.01)) * 0.01,
  (
    FLOOR(((`la_crime_data`.`Longitude` - -118.66) / 0.01)) * 0.01
  ) + -118.66
ORDER BY
  FLOOR((`la_crime_data`.`Latitude` / 0.01)) * 0.01 ASC,
  (
    FLOOR(((`la_crime_data`.`Longitude` - -118.66) / 0.01)) * 0.01
  ) + -118.66 ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.055
  Output Similarity: 0.000
  Execution Time: 2.762 seconds

Test 87:
  NLQ: For each coordinate in latitude and longitude of LA spaced by 0.01 degrees, give the most common crime type and its count
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  Latitude,
  Longitude,
  Most_Common_Crime_Type,
  count
FROM (
  SELECT
    FLOOR((`la_crime_data`.`Latitude` / 0.015)) * 0.015 AS Latitude,
    (
      FLOOR(((`la_crime_data`.`Longitude` - -118.66) / 0.015)) * 0.015
    ) + -118.66 AS Longitude,
    Crime_Type AS Most_Common_Crime_Type,
    COUNT(*) AS count,
    ROW_NUMBER() OVER(PARTITION BY
      FLOOR((`la_crime_data`.`Latitude` / 0.015)) * 0.015,
      (
        FLOOR(((`la_crime_data`.`Longitude` - -118.66) / 0.015)) * 0.015
      ) + -118.66
    ORDER BY COUNT(*) DESC
    ) AS crime_rank
  FROM
    `la_crime_data`
  GROUP BY
    Latitude,
    Longitude,
    Crime_Type
) AS ranked_crimes
WHERE
  crime_rank = 1
ORDER BY
  Latitude ASC,
  Longitude ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.046
  Output Similarity: 0.000
  Execution Time: 2.760 seconds

Test 88:
  NLQ: For each coordinate in latitude and longitude of New York spaced by 0.01 degrees, give the total crime count.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  (
    FLOOR(((`nyc_crime_data`.`Latitude` - 40.49) / 0.01)) * 0.01
  ) + 40.49 AS `Latitude`,
  (
    FLOOR(((`nyc_crime_data`.`Longitude` - -74.27) / 0.01)) * 0.01
  ) + -74.27 AS `Longitude`,
  COUNT(*) AS `count`
FROM
  `nyc_crime_data`
GROUP BY
  (
    FLOOR(((`nyc_crime_data`.`Latitude` - 40.49) / 0.01)) * 0.01
  ) + 40.49,
  (
    FLOOR(((`nyc_crime_data`.`Longitude` - -74.27) / 0.01)) * 0.01
  ) + -74.27
ORDER BY
  (
    FLOOR(((`nyc_crime_data`.`Latitude` - 40.49) / 0.01)) * 0.01
  ) + 40.49 ASC,
  (
    FLOOR(((`nyc_crime_data`.`Longitude` - -74.27) / 0.01)) * 0.01
  ) + -74.27 ASC

  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.051
  Output Similarity: 0.000
  Execution Time: 1.294 seconds

Test 89:
  NLQ: For each coordinate in latitude and longitude of New York spaced by 0.01 degrees, give the most common crime type and its count
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  Latitude,
  Longitude,
  Most_Common_Crime_Type,
  count
FROM (
  SELECT
    FLOOR((Latitude - 40.49) / 0.01) * 0.01 + 40.49 AS Latitude,
    FLOOR((Longitude - -74.27) / 0.01) * 0.01 - 74.27 AS Longitude,
    Crime_Type AS Most_Common_Crime_Type,
    COUNT(*) AS count,
    ROW_NUMBER() OVER(PARTITION BY
      FLOOR((Latitude - 40.49) / 0.01) * 0.01 + 40.49,
      FLOOR((Longitude - -74.27) / 0.01) * 0.01 - 74.27
    ORDER BY COUNT(*) DESC
    ) AS crime_rank
  FROM
    nyc_crime_data
  WHERE
    Latitude != 0
    AND Longitude != 0
  GROUP BY
    Latitude,
    Longitude,
    Crime_Type
) AS ranked_crimes
WHERE
  crime_rank = 1
ORDER BY
  Latitude ASC,
  Longitude ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.060
  Output Similarity: 0.000
  Execution Time: 1.291 seconds

Test 90:
  NLQ: For each coordinate in latitude and longitude of Philly spaced by 0.01 degrees, give the total crime count.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  (
    FLOOR(((`philly_crime_data`.`Latitude` - 39.86) / 0.01)) * 0.01
  ) + 39.86 AS `Latitude`,
  (
    FLOOR(((`philly_crime_data`.`Longitude` - -75.28) / 0.01)) * 0.01
  ) + -75.28 AS `Longitude`,
  COUNT(*) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  (
    FLOOR(((`philly_crime_data`.`Latitude` - 39.86) / 0.01)) * 0.01
  ) + 39.86,
  (
    FLOOR(((`philly_crime_data`.`Longitude` - -75.28) / 0.01)) * 0.01
  ) + -75.28
ORDER BY
  (
    FLOOR(((`philly_crime_data`.`Latitude` - 39.86) / 0.01)) * 0.01
  ) + 39.86 ASC,
  (
    FLOOR(((`philly_crime_data`.`Longitude` - -75.28) / 0.01)) * 0.01
  ) + -75.28 ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.054
  Output Similarity: 0.000
  Execution Time: 2.327 seconds

Test 91:
  NLQ: For each coordinate in latitude and longitude of Philly spaced by 0.01 degrees, give the most common crime type and its count
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
    Latitude,
    Longitude,
    Most_Common_Crime_Type,
    count
FROM (
    SELECT
        FLOOR((Latitude - 39.86) / 0.01) * 0.01 + 39.86 AS Latitude,
        FLOOR((Longitude + 75.28) / 0.01) * 0.01 - 75.28 AS Longitude,
        Crime_Type AS Most_Common_Crime_Type,
        COUNT(*) AS count,
        ROW_NUMBER() OVER(PARTITION BY
            FLOOR((Latitude - 39.86) / 0.01) * 0.01 + 39.86,
            FLOOR((Longitude + 75.28) / 0.01) * 0.01 - 75.28
            ORDER BY COUNT(*) DESC
        ) AS crime_rank
    FROM
        philly_crime_data
    WHERE
        Latitude != 0
        AND Longitude != 0
    GROUP BY
        FLOOR((Latitude - 39.86) / 0.01) * 0.01 + 39.86,
        FLOOR((Longitude + 75.28) / 0.01) * 0.01 - 75.28,
        Crime_Type
) AS ranked_crimes
WHERE
    crime_rank = 1
ORDER BY
    Latitude ASC,
    Longitude ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.067
  Output Similarity: 0.000
  Execution Time: 2.321 seconds

Test 92:
  NLQ: Give the total count of each crime type in Atlanta
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  `atlanta_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  `atlanta_crime_data`.`Crime_Type`
ORDER BY
  `atlanta_crime_data`.`Crime_Type` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.166
  Output Similarity: 0.000
  Execution Time: 0.896 seconds

Test 93:
  NLQ: For each crime type in Atlanta, give its total count, last reported date, last reported area, most common area for this crime type, and percentage increase in this crime type by week.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
    a.Crime_Type,
    COUNT(*) AS Total_Count,
    MAX(a.Crime_Date) AS Last_Date_Reported,
    MAX(a.Area_Name) AS Last_Area_Reported,
    ANY_VALUE(b.Most_Common_Area) AS Most_Prevalent_Area,
    IFNULL((SUM(CASE WHEN a.Crime_Date >= (SELECT MAX(Crime_Date) FROM atlanta_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) / COUNT(*)) * 100, 0) AS Crime_Increase_Proportion
FROM
    atlanta_crime_data a
LEFT JOIN (
    SELECT
        Crime_Type,
        Area_Name AS Most_Common_Area
    FROM (
        SELECT
            Crime_Type,
            Area_Name,
            ROW_NUMBER() OVER(PARTITION BY Crime_Type ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            atlanta_crime_data
        GROUP BY
            Crime_Type, Area_Name
    ) ranked_areas
    WHERE
        crime_rank = 1
) b ON a.Crime_Type = b.Crime_Type
GROUP BY
    a.Crime_Type
ORDER BY
    a.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.051
  Output Similarity: 0.000
  Execution Time: 0.898 seconds

Test 94:
  NLQ: Give the total count of each crime type in LA
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  `la_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `la_crime_data`
GROUP BY
  `la_crime_data`.`Crime_Type`
ORDER BY
  `la_crime_data`.`Crime_Type` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.156
  Output Similarity: 0.000
  Execution Time: 2.767 seconds

Test 95:
  NLQ: For each crime type in LA, give its total count, last reported date, last reported area, most common area for this crime type, and percentage increase in this crime type by week.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
    a.Crime_Type,
    COUNT(*) AS Total_Count,
    MAX(a.Crime_Date) AS Last_Date_Reported,
    MAX(a.Area_Name) AS Last_Area_Reported,
    ANY_VALUE(b.Most_Common_Area) AS Most_Prevalent_Area,
    IFNULL((SUM(CASE WHEN a.Crime_Date >= (SELECT MAX(Crime_Date) FROM la_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) / COUNT(*)) * 100, 0) AS Crime_Increase_Proportion
FROM
    la_crime_data a
LEFT JOIN (
    SELECT
        Crime_Type,
        Area_Name AS Most_Common_Area
    FROM (
        SELECT
            Crime_Type,
            Area_Name,
            ROW_NUMBER() OVER(PARTITION BY Crime_Type ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            la_crime_data
        GROUP BY
            Crime_Type, Area_Name
    ) ranked_areas
    WHERE
        crime_rank = 1
) b ON a.Crime_Type = b.Crime_Type
GROUP BY
    a.Crime_Type
ORDER BY
    a.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.044
  Output Similarity: 0.000
  Execution Time: 2.768 seconds

Test 96:
  NLQ: Give the total count of each crime type in New York
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  `nyc_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `nyc_crime_data`
GROUP BY
  `nyc_crime_data`.`Crime_Type`
ORDER BY
  `nyc_crime_data`.`Crime_Type` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.158
  Output Similarity: 0.000
  Execution Time: 1.291 seconds

Test 97:
  NLQ: For each crime type in New York, give its total count, last reported date, last reported area, most common area for this crime type, and percentage increase in this crime type by week.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
    a.Crime_Type,
    COUNT(*) AS Total_Count,
    MAX(a.Crime_Date) AS Last_Date_Reported,
    MAX(a.Area_Name) AS Last_Area_Reported,
    ANY_VALUE(b.Most_Common_Area) AS Most_Prevalent_Area,
    IFNULL((SUM(CASE WHEN a.Crime_Date >= (SELECT MAX(Crime_Date) FROM nyc_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) / COUNT(*)) * 100, 0) AS Crime_Increase_Proportion
FROM
    nyc_crime_data a
LEFT JOIN (
    SELECT
        Crime_Type,
        Area_Name AS Most_Common_Area
    FROM (
        SELECT
            Crime_Type,
            Area_Name,
            ROW_NUMBER() OVER(PARTITION BY Crime_Type ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            nyc_crime_data
        GROUP BY
            Crime_Type, Area_Name
    ) ranked_areas
    WHERE
        crime_rank = 1
) b ON a.Crime_Type = b.Crime_Type
GROUP BY
    a.Crime_Type
ORDER BY
    a.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.045
  Output Similarity: 0.000
  Execution Time: 1.294 seconds

Test 98:
  NLQ: Give the total count of each crime type in Philly
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  `philly_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  `philly_crime_data`.`Crime_Type`
ORDER BY
  `philly_crime_data`.`Crime_Type` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.164
  Output Similarity: 0.000
  Execution Time: 2.322 seconds

Test 99:
  NLQ: For each crime type in Philly, give its total count, last reported date, last reported area, most common area for this crime type, and percentage increase in this crime type by week.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
    a.Crime_Type,
    COUNT(*) AS Total_Count,
    MAX(a.Crime_Date) AS Last_Date_Reported,
    MAX(a.`Area_#`) AS Last_Area_Reported,
    ANY_VALUE(b.Most_Common_Area) AS Most_Prevalent_Area,
    IFNULL((SUM(CASE WHEN a.Crime_Date >= (SELECT MAX(Crime_Date) FROM philly_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) / COUNT(*)) * 100, 0) AS Crime_Increase_Proportion
FROM
    philly_crime_data a
LEFT JOIN (
    SELECT
        Crime_Type,
        `Area_#` AS Most_Common_Area
    FROM (
        SELECT
            Crime_Type,
            `Area_#`,
            ROW_NUMBER() OVER(PARTITION BY Crime_Type ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            philly_crime_data
        GROUP BY
            Crime_Type, `Area_#`
    ) ranked_areas
    WHERE
        crime_rank = 1
) b ON a.Crime_Type = b.Crime_Type
GROUP BY
    a.Crime_Type
ORDER BY
    a.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.050
  Output Similarity: 0.000
  Execution Time: 2.324 seconds

Test 100:
  NLQ: For each area in Atlanta, give count of each crime type.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  `atlanta_crime_data`.`Area_Name` AS `Area_Name`,
  `atlanta_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  `atlanta_crime_data`.`Area_Name`,
  `atlanta_crime_data`.`Crime_Type`
ORDER BY
  `atlanta_crime_data`.`Area_Name` ASC,
  `atlanta_crime_data`.`Crime_Type` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.102
  Output Similarity: 0.000
  Execution Time: 0.896 seconds

Test 101:
  NLQ: For each area in LA, give count of each crime type.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  `la_crime_data`.`Area_Name` AS `Area_Name`,
  CASE 
    WHEN `la_crime_data`.`Crime_Type` IN ('ASSAULT WITH DEADLY WEAPON', 'AGGRAVATED ASSAULT') THEN 'ASSAULT WITH DEADLY WEAPON, AGGRAVATED ASSAULT'
    WHEN `la_crime_data`.`Crime_Type` = 'BATTERY - SIMPLE ASSAULT' THEN 'BATTERY - SIMPLE ASSAULT'
    WHEN `la_crime_data`.`Crime_Type` = 'BURGLARY' THEN 'BURGLARY'
    WHEN `la_crime_data`.`Crime_Type` = 'BURGLARY FROM VEHICLE' THEN 'BURGLARY FROM VEHICLE'
    WHEN `la_crime_data`.`Crime_Type` = 'INTIMATE PARTNER - SIMPLE ASSAULT' THEN 'INTIMATE PARTNER - SIMPLE ASSAULT'
    WHEN `la_crime_data`.`Crime_Type` = 'ROBBERY' THEN 'ROBBERY'
    WHEN `la_crime_data`.`Crime_Type` = 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)' THEN 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)'
    WHEN `la_crime_data`.`Crime_Type` = 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)' THEN 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)'
    WHEN `la_crime_data`.`Crime_Type` = 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)' THEN 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)'
    WHEN `la_crime_data`.`Crime_Type` = 'THEFT OF IDENTITY' THEN 'THEFT OF IDENTITY'
    WHEN `la_crime_data`.`Crime_Type` = 'THEFT PLAIN - PETTY ($950 & UNDER)' THEN 'THEFT PLAIN - PETTY ($950 & UNDER)'
    WHEN `la_crime_data`.`Crime_Type` = 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD' THEN 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD'
    WHEN `la_crime_data`.`Crime_Type` = 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)' THEN 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)'
    WHEN `la_crime_data`.`Crime_Type` = 'VANDALISM - MISDEMEANOR ($399 OR UNDER)' THEN 'VANDALISM - MISDEMEANOR ($399 OR UNDER)'
    WHEN `la_crime_data`.`Crime_Type` = 'VEHICLE - STOLEN' THEN 'VEHICLE - STOLEN'
    ELSE 'Other'
  END AS `Crime_Type_Grouped`,
  COUNT(*) AS `Count`
FROM
  `la_crime_data`
GROUP BY
  `Area_Name`,
  `Crime_Type_Grouped`
ORDER BY
  `Area_Name` ASC,
  `Crime_Type_Grouped` ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.015
  Output Similarity: 0.000
  Execution Time: 2.764 seconds

Test 102:
  NLQ: For each area in New York, give count of each crime type.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  `nyc_crime_data`.`Crime_Type` AS `Crime_Type`,
  `nyc_crime_data`.`Area_Name` AS `Area_Name`,
  COUNT(*) AS `count`
FROM
  `nyc_crime_data`
GROUP BY
  `nyc_crime_data`.`Crime_Type`,
  `nyc_crime_data`.`Area_Name`
ORDER BY
  `nyc_crime_data`.`Crime_Type` ASC,
  `nyc_crime_data`.`Area_Name` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.098
  Output Similarity: 0.000
  Execution Time: 1.292 seconds

Test 103:
  NLQ: For each area in Philly, give count of each crime type.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  `philly_crime_data`.`Crime_Type` AS `Crime_Type`,
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10 AS `Area_#`,
  COUNT(*) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  `philly_crime_data`.`Crime_Type`,
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10
ORDER BY
  `philly_crime_data`.`Crime_Type` ASC,
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10 ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.088
  Output Similarity: 0.000
  Execution Time: 2.325 seconds

Test 104:
  NLQ: Give count of each crime type for each day of the week in Atlanta.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(acd.Crime_Date) AS Crime_Day_Number,
  DAYNAME(acd.Crime_Date) AS Crime_Day_Name,
  acd.Crime_Type AS Crime_Type,
  COUNT(*) AS Crime_Count
FROM
  atlanta_crime_data acd
WHERE
  DAYOFWEEK(acd.Crime_Date) IS NOT NULL
GROUP BY
  DAYOFWEEK(acd.Crime_Date),
  DAYNAME(acd.Crime_Date),
  acd.Crime_Type
ORDER BY
  Crime_Day_Number,
  acd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.149
  Output Similarity: 0.000
  Execution Time: 0.897 seconds

Test 105:
  NLQ: Give count of each crime type for each hour of the day in Atlanta.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  CASE
    WHEN HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s')) = 0 THEN 24
    ELSE HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s'))
  END AS `Crime_Hour`,
  `atlanta_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  CASE
    WHEN HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s')) = 0 THEN 24
    ELSE HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s'))
  END,
  `atlanta_crime_data`.`Crime_Type`
ORDER BY
  `Crime_Hour` ASC,
  `Crime_Type` ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.062
  Output Similarity: 0.000
  Execution Time: 0.898 seconds

Test 106:
  NLQ: Give count of each crime type for each month in Atlanta.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
    MONTH(acd.Crime_Date) AS Month,
    acd.Crime_Type AS Crime_Type,
    COUNT(*) AS Crime_Count
FROM
    atlanta_crime_data acd
GROUP BY
    MONTH(acd.Crime_Date),
    acd.Crime_Type
ORDER BY
    MONTH(acd.Crime_Date),
    acd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.153
  Output Similarity: 0.000
  Execution Time: 0.904 seconds

Test 107:
  NLQ: Give count of each crime type for each day of the week in LA.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(lcd.Crime_Date) AS Crime_Day_Number,
  DAYNAME(lcd.Crime_Date) AS Crime_Day_Name,
  CASE 
    WHEN lcd.Crime_Type IN ('ASSAULT WITH DEADLY WEAPON', 'AGGRAVATED ASSAULT') THEN 'ASSAULT WITH DEADLY WEAPON, AGGRAVATED ASSAULT'
    WHEN lcd.Crime_Type = 'BATTERY - SIMPLE ASSAULT' THEN 'BATTERY - SIMPLE ASSAULT'
    WHEN lcd.Crime_Type = 'BURGLARY' THEN 'BURGLARY'
    WHEN lcd.Crime_Type = 'BURGLARY FROM VEHICLE' THEN 'BURGLARY FROM VEHICLE'
    WHEN lcd.Crime_Type = 'INTIMATE PARTNER - SIMPLE ASSAULT' THEN 'INTIMATE PARTNER - SIMPLE ASSAULT'
    WHEN lcd.Crime_Type = 'ROBBERY' THEN 'ROBBERY'
    WHEN lcd.Crime_Type = 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)' THEN 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)' THEN 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)'
    WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)' THEN 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT OF IDENTITY' THEN 'THEFT OF IDENTITY'
    WHEN lcd.Crime_Type = 'THEFT PLAIN - PETTY ($950 & UNDER)' THEN 'THEFT PLAIN - PETTY ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD' THEN 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD'
    WHEN lcd.Crime_Type = 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)' THEN 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)'
    WHEN lcd.Crime_Type = 'VANDALISM - MISDEMEANOR ($399 OR UNDER)' THEN 'VANDALISM - MISDEMEANOR ($399 OR UNDER)'
    WHEN lcd.Crime_Type = 'VEHICLE - STOLEN' THEN 'VEHICLE - STOLEN'
    ELSE 'Other'
  END AS Crime_Type_Grouped,
  COUNT(*) AS Crime_Count
FROM
  la_crime_data lcd
GROUP BY
  Crime_Day_Number,
  Crime_Day_Name,
  Crime_Type_Grouped
ORDER BY
  Crime_Day_Number,
  Crime_Type_Grouped;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.016
  Output Similarity: 0.000
  Execution Time: 2.769 seconds

Test 108:
  NLQ: Give count of each crime type for each hour of the day in LA.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  FLOOR(lcd.Crime_Time / 100) + 1 AS Hour,
  CASE 
    WHEN lcd.Crime_Type IN ('ASSAULT WITH DEADLY WEAPON', 'AGGRAVATED ASSAULT') THEN 'ASSAULT WITH DEADLY WEAPON, AGGRAVATED ASSAULT'
    WHEN lcd.Crime_Type = 'BATTERY - SIMPLE ASSAULT' THEN 'BATTERY - SIMPLE ASSAULT'
    WHEN lcd.Crime_Type = 'BURGLARY' THEN 'BURGLARY'
    WHEN lcd.Crime_Type = 'BURGLARY FROM VEHICLE' THEN 'BURGLARY FROM VEHICLE'
    WHEN lcd.Crime_Type = 'INTIMATE PARTNER - SIMPLE ASSAULT' THEN 'INTIMATE PARTNER - SIMPLE ASSAULT'
    WHEN lcd.Crime_Type = 'ROBBERY' THEN 'ROBBERY'
    WHEN lcd.Crime_Type = 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)' THEN 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)' THEN 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)'
    WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)' THEN 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT OF IDENTITY' THEN 'THEFT OF IDENTITY'
    WHEN lcd.Crime_Type = 'THEFT PLAIN - PETTY ($950 & UNDER)' THEN 'THEFT PLAIN - PETTY ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD' THEN 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD'
    WHEN lcd.Crime_Type = 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)' THEN 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)'
    WHEN lcd.Crime_Type = 'VANDALISM - MISDEMEANOR ($399 OR UNDER)' THEN 'VANDALISM - MISDEMEANOR ($399 OR UNDER)'
    WHEN lcd.Crime_Type = 'VEHICLE - STOLEN' THEN 'VEHICLE - STOLEN'
    ELSE 'Other'
  END AS Crime_Type_Grouped,
  COUNT(*) AS Count
FROM
  la_crime_data lcd
GROUP BY
  Hour,
  Crime_Type_Grouped
ORDER BY
  Hour ASC,
  Crime_Type_Grouped ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.016
  Output Similarity: 0.000
  Execution Time: 2.758 seconds

Test 109:
  NLQ: Give count of each crime type for each month in LA.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
    MONTH(lcd.Crime_Date) AS Month,
    CASE 
        WHEN lcd.Crime_Type IN ('ASSAULT WITH DEADLY WEAPON', 'AGGRAVATED ASSAULT') THEN 'ASSAULT WITH DEADLY WEAPON, AGGRAVATED ASSAULT'
        WHEN lcd.Crime_Type = 'BATTERY - SIMPLE ASSAULT' THEN 'BATTERY - SIMPLE ASSAULT'
        WHEN lcd.Crime_Type = 'BURGLARY' THEN 'BURGLARY'
        WHEN lcd.Crime_Type = 'BURGLARY FROM VEHICLE' THEN 'BURGLARY FROM VEHICLE'
        WHEN lcd.Crime_Type = 'INTIMATE PARTNER - SIMPLE ASSAULT' THEN 'INTIMATE PARTNER - SIMPLE ASSAULT'
        WHEN lcd.Crime_Type = 'ROBBERY' THEN 'ROBBERY'
        WHEN lcd.Crime_Type = 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)' THEN 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)'
        WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)' THEN 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)'
        WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)' THEN 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)'
        WHEN lcd.Crime_Type = 'THEFT OF IDENTITY' THEN 'THEFT OF IDENTITY'
        WHEN lcd.Crime_Type = 'THEFT PLAIN - PETTY ($950 & UNDER)' THEN 'THEFT PLAIN - PETTY ($950 & UNDER)'
        WHEN lcd.Crime_Type = 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD' THEN 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD'
        WHEN lcd.Crime_Type = 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)' THEN 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)'
        WHEN lcd.Crime_Type = 'VANDALISM - MISDEMEANOR ($399 OR UNDER)' THEN 'VANDALISM - MISDEMEANOR ($399 OR UNDER)'
        WHEN lcd.Crime_Type = 'VEHICLE - STOLEN' THEN 'VEHICLE - STOLEN'
        ELSE 'Other'
    END AS Crime_Type_Grouped,
    COUNT(*) AS Crime_Count
FROM
    la_crime_data lcd
GROUP BY
    Month,
    Crime_Type_Grouped
ORDER BY
    Month,
    Crime_Type_Grouped;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.017
  Output Similarity: 0.000
  Execution Time: 2.762 seconds

Test 110:
  NLQ: Give count of each crime type for each day of the week in New York.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(ncd.Crime_Date) AS Crime_Day_Number,
  DAYNAME(ncd.Crime_Date) AS Crime_Day_Name,
  ncd.Crime_Type AS Crime_Type,
  COUNT(*) AS Crime_Count
FROM
  nyc_crime_data ncd
WHERE
  DAYOFWEEK(ncd.Crime_Date) IS NOT NULL
GROUP BY
  DAYOFWEEK(ncd.Crime_Date),
  DAYNAME(ncd.Crime_Date),
  ncd.Crime_Type
ORDER BY
  Crime_Day_Number,
  ncd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.134
  Output Similarity: 0.000
  Execution Time: 1.295 seconds

Test 111:
  NLQ: Give count of each crime type for each hour of the day in New York.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  HOUR(ncd.Crime_Time) + 1 AS Hour,
  ncd.Crime_Type AS Crime_Type,
  COUNT(*) AS Count
FROM
  nyc_crime_data ncd
GROUP BY
  Hour,
  ncd.Crime_Type
ORDER BY
  Hour ASC,
  ncd.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.160
  Output Similarity: 0.000
  Execution Time: 1.294 seconds

Test 112:
  NLQ: Give count of each crime type for each month in New York.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
    MONTH(ncd.Crime_Date) AS Month,
    ncd.Crime_Type AS Crime_Type,
    COUNT(*) AS Crime_Count
FROM
    nyc_crime_data ncd
GROUP BY
    MONTH(ncd.Crime_Date),
    ncd.Crime_Type
ORDER BY
    MONTH(ncd.Crime_Date),
    ncd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.137
  Output Similarity: 0.000
  Execution Time: 1.293 seconds

Test 113:
  NLQ: Give count of each crime type for each day of the week in Philly.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(pcd.Crime_Date) AS Crime_Day_Number,
  DAYNAME(pcd.Crime_Date) AS Crime_Day_Name,
  pcd.Crime_Type AS Crime_Type,
  COUNT(*) AS Crime_Count
FROM
  philly_crime_data pcd
GROUP BY
  DAYOFWEEK(pcd.Crime_Date),
  DAYNAME(pcd.Crime_Date),
  pcd.Crime_Type
ORDER BY
  Crime_Day_Number,
  pcd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.108
  Output Similarity: 0.000
  Execution Time: 2.323 seconds

Test 114:
  NLQ: Give count of each crime type for each hour of the day in Philly.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  HOUR(pcd.Crime_Time) + 1 AS Hour,
  pcd.Crime_Type AS Crime_Type,
  COUNT(*) AS Count
FROM
  philly_crime_data pcd
GROUP BY
  Hour,
  pcd.Crime_Type
ORDER BY
  Hour ASC,
  pcd.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.174
  Output Similarity: 0.000
  Execution Time: 2.322 seconds

Test 115:
  NLQ: Give count of each crime type for each month in Philly.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
    MONTH(pcd.Crime_Date) AS Month,
    pcd.Crime_Type AS Crime_Type,
    COUNT(*) AS Crime_Count
FROM
    philly_crime_data pcd
GROUP BY
    MONTH(pcd.Crime_Date),
    pcd.Crime_Type
ORDER BY
    MONTH(pcd.Crime_Date),
    pcd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.150
  Output Similarity: 0.000
  Execution Time: 2.322 seconds

Test 116:
  NLQ: Get count of mass shootings for each month in USA.
  Predicted SQL: SELECT * FROM us_shootings;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) AS `IncidentDate`,
  COUNT(*) AS `count`
FROM
  `us_shootings`
GROUP BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.069
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 117:
  NLQ: Get count of homeless population and US shooting incidents for each year.
  Predicted SQL: SELECT * FROM experiencing_homelessness_age_demographics;
  Ground Truth SQL: SELECT * FROM 
(SELECT Count(*) as IncidentCount, year(IncidentDate) as IncidentYear   FROM us_shootings GROUP BY IncidentYear) T1
JOIN
(SELECT sum(EXPERIENCING_HOMELESSNESS_CNT) as HomelessnessCount, CALENDAR_YEAR FROM experiencing_homelessness_age_demographics group by CALENDAR_YEAR) T2
ON T2.CALENDAR_YEAR = T1.IncidentYear 
ORDER BY IncidentCount DESC 
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.159
  Output Similarity: 0.000
  Execution Time: 0.003 seconds

Test 118:
  NLQ: Get homeless population per capita for each county of California.
  Predicted SQL: SELECT * FROM experiencing_homelessness_age_demographics;
  Ground Truth SQL: SELECT T2.County, (CAST(T1.HomelessnessCount AS decimal) / CAST((T2.PopulationCountSum) AS decimal)) AS HomelessnessCountCapita FROM
(SELECT sum(EXPERIENCING_HOMELESSNESS_CNT) as HomelessnessCount, lower(LOCATION) as Area FROM experiencing_homelessness_age_demographics WHERE LOCATION NOT LIKE "california" group by Area order by HomelessnessCount) T1
join
(SELECT County, Sum(PopulationCount) as PopulationCountSum FROM us_population_county GROUP BY County) T2
ON T1.Area LIKE concat('%', T2.County, '%')
ORDER BY HomelessnessCountCapita DESC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.179
  Output Similarity: 0.000
  Execution Time: 0.003 seconds

Test 119:
  NLQ: Get homeless population per capita and US shooting incidents per million capita for each county of California.
  Predicted SQL: SELECT * FROM experiencing_homelessness_age_demographics;
  Ground Truth SQL: 

SELECT T5.County, T5.HomelessnessCountCapita, T6.ShootingsPerMillionCapita FROM
(
SELECT T2.County , (CAST(T1.HomelessnessCount AS decimal) / CAST((T2.PopulationCountSum) AS decimal)) AS HomelessnessCountCapita FROM
(SELECT sum(EXPERIENCING_HOMELESSNESS_CNT) as HomelessnessCount, lower(LOCATION) as Area FROM experiencing_homelessness_age_demographics WHERE LOCATION NOT LIKE "california" AND CALENDAR_YEAR=2020 AND LOCATION NOT LIKE '%(los angeles county)%' group by Area order by HomelessnessCount) T1
join
(SELECT County, Sum(PopulationCount) as PopulationCountSum FROM us_population_county GROUP BY County) T2
ON T1.Area LIKE concat('%', T2.County, '%')
) T5
JOIN
(
SELECT T4.County, (CAST(T3.IncidentCount AS decimal) / CAST((T4.PopulationCount/1000000) AS decimal)) AS ShootingsPerMillionCapita FROM 
(SELECT CityOrCounty, Count(*) AS IncidentCount from us_shootings GROUP BY CityOrCounty) T3
JOIN 
(SELECT County, PopulationCount FROM us_population_county GROUP BY County, PopulationCount) T4
ON T3.CityOrCounty LIKE T4.County
) T6
ON T5.County LIKE concat('%', T6.County, '%')
ORDER BY ShootingsPerMillionCapita DESC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.140
  Output Similarity: 0.000
  Execution Time: 0.003 seconds

Test 120:
  NLQ: For each county, get shooting incidents per million capita, and income per million capita.
  Predicted SQL: SELECT * FROM food_access;
  Ground Truth SQL: SELECT T5.County, T5.MedianFamilyIncomePerMillionCapita, T6.ShootingsPerMillionCapita FROM
(
SELECT T2.County , (CAST(T1.MedianFamilyIncome AS decimal) / CAST((T2.PopulationCountSum/1000000) AS decimal)) AS MedianFamilyIncomePerMillionCapita FROM
(SELECT avg(MedianFamilyIncome) as MedianFamilyIncome, lower(County) as Area FROM food_access group by Area order by MedianFamilyIncome) T1
join
(SELECT County, Sum(PopulationCount) as PopulationCountSum FROM us_population_county GROUP BY County) T2
ON T1.Area LIKE concat('%', T2.County, '%')
) T5
JOIN
(
SELECT T4.County, (CAST(T3.IncidentCount AS decimal) / CAST((T4.PopulationCount/1000000) AS decimal)) AS ShootingsPerMillionCapita FROM 
(SELECT CityOrCounty, Count(*) AS IncidentCount from us_shootings GROUP BY CityOrCounty) T3
JOIN 
(SELECT County, PopulationCount FROM us_population_county GROUP BY County, PopulationCount) T4
ON T3.CityOrCounty LIKE T4.County
) T6
ON T5.County LIKE concat('%', T6.County, '%')
ORDER BY ShootingsPerMillionCapita DESC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.024
  Output Similarity: 0.000
  Execution Time: 1.025 seconds

Test 121:
  NLQ: For each state, get shooting incidents per million capita, and income per million capita.
  Predicted SQL: SELECT * FROM food_access;
  Ground Truth SQL: SELECT T5.State, T5.MedianFamilyIncomePerMillionCapita, T6.ShootingsPerMillionCapita FROM
(
SELECT T2.State , (CAST(T1.MedianFamilyIncome AS decimal) / CAST((T2.PopulationCountSum/1000000) AS decimal)) AS MedianFamilyIncomePerMillionCapita FROM
(SELECT avg(MedianFamilyIncome) as MedianFamilyIncome, lower(State) as State FROM food_access group by State order by MedianFamilyIncome) T1
join
(SELECT State, Sum(PopulationCount) as PopulationCountSum FROM us_population GROUP BY State) T2
ON T1.State LIKE concat('%', T2.State, '%')
) T5
JOIN
(
SELECT T4.State, (CAST(T3.IncidentCount AS decimal) / CAST((T4.PopulationCount/1000000) AS decimal)) AS ShootingsPerMillionCapita FROM 
(SELECT State, Count(*) AS IncidentCount from us_shootings GROUP BY State) T3
JOIN 
(SELECT State, PopulationCount FROM us_population GROUP BY State, PopulationCount) T4
ON T3.State LIKE T4.State
) T6
ON T5.State LIKE concat('%', T6.State, '%')
ORDER BY ShootingsPerMillionCapita DESC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.025
  Output Similarity: 0.000
  Execution Time: 1.030 seconds

Test 122:
  NLQ: Get count of suspects arrested each month over the years.
  Predicted SQL: SELECT * FROM us_shootings;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) AS `IncidentDate`,
  SUM(`us_shootings`.`SuspectsArrested`) AS `sum`,
  AVG(`us_shootings`.`SuspectsArrested`) AS `avg`
FROM
  `us_shootings`
GROUP BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) ASC

  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.055
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 123:
  NLQ: Get count of victims injured, suspects arrested and suspects killed for each incident.
  Predicted SQL: SELECT * FROM us_shootings;
  Ground Truth SQL: SELECT SUM(VictimsInjured) AS VictimsInjured, Sum(SuspectsArrested) AS SuspectsArrested, SUM(SuspectsKilled) AS SuspectsKilled, IncidentDate FROM us_shootings WHERE IncidentDate != '20171001' GROUP BY IncidentDate
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.117
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 124:
  NLQ: For each month, get count of victims killed and average of victims killed in each shooting incident.
  Predicted SQL: SELECT * FROM us_shootings;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) AS `IncidentDate`,
  SUM(`us_shootings`.`VictimsKilled`) AS `sum`,
  AVG(`us_shootings`.`VictimsKilled`) AS `avg`
FROM
  `us_shootings`
GROUP BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.056
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 125:
  NLQ: For each county, get victims killed per million capita, victims injured per million capita, suspects arrested per million capita, and incident counts for million capita.
  Predicted SQL: SELECT * FROM us_shootings;
  Ground Truth SQL: SELECT T1.County, (CAST(T1.VictimsKilled as decimal) / CAST((T2.PopulationCount/1000000) AS decimal)) AS VictimsKilledPerCapita, (CAST(T1.VictimsInjured as decimal) / CAST((T2.PopulationCount/1000000) AS decimal)) AS VictimsInjuredPerCapita, 
(CAST(T1.IncidentCount as decimal) / CAST((T2.PopulationCount/1000000) AS decimal)) AS IncidentCountPerCapita, (CAST(T1.SuspectsArrested as decimal) / CAST((T2.PopulationCount/1000000) AS decimal)) AS SuspectsArrestedPerCapita FROM
(Select sum(VictimsKilled) as VictimsKilled, SUM(VictimsInjured) as VictimsInjured, Count(*) AS IncidentCount, Sum(SuspectsArrested) AS SuspectsArrested, lower(CityOrCounty) as County from us_shootings group by County) T1
JOIN 
(SELECT County, Sum(PopulationCount) as PopulationCount FROM us_population_county GROUP BY County) T2
ON T2.County LIKE T1.County
ORDER BY VictimsKilledPerCapita DESC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.030
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 126:
  NLQ: Give total crimes occurred in Atlanta on each day of the week
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(`atlanta_crime_data`.`Crime_Date`) AS `Crime_Date`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  DAYOFWEEK(`atlanta_crime_data`.`Crime_Date`)
ORDER BY
  DAYOFWEEK(`atlanta_crime_data`.`Crime_Date`) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.142
  Output Similarity: 0.000
  Execution Time: 0.896 seconds

Test 127:
  NLQ: Give total crimes occurred in Atlanta during each month of the year
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
    MONTH(Crime_Date) AS Month,
    COUNT(*) AS Crime_Count
FROM
    atlanta_crime_data
GROUP BY
    MONTH(Crime_Date)
ORDER BY
    MONTH(Crime_Date);
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.241
  Output Similarity: 0.000
  Execution Time: 0.897 seconds

Test 128:
  NLQ: Give total crimes occurred in Atlanta at each hour of the day
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  CASE
    WHEN HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s')) = 0 THEN 24
    ELSE HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s'))
  END AS `Hour`,
  COUNT(*) AS `Count`
FROM
  `atlanta_crime_data`
GROUP BY
  `Hour`
ORDER BY
  `Hour` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.123
  Output Similarity: 0.000
  Execution Time: 0.897 seconds

Test 129:
  NLQ: Give total count of crimes in Atlanta grouped by week since January 2009
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`atlanta_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) AS `Crime_Date`,
  count(distinct `atlanta_crime_data`.`Report_#`) AS `count`
FROM
  `atlanta_crime_data`
WHERE
  `atlanta_crime_data`.`Crime_Date` >= convert_tz(
    '2009-01-05 00:00:00.000',
    'America/New_York',
    @@session.time_zone
  )
GROUP BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`atlanta_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`atlanta_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.102
  Output Similarity: 0.000
  Execution Time: 0.897 seconds

Test 130:
  NLQ: Give total crimes occurred in LA on each day of the week
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(`la_crime_data`.`Crime_Date`) AS `Crime_Date`,
  COUNT(*) AS `count`
FROM
  `la_crime_data`
GROUP BY
  DAYOFWEEK(`la_crime_data`.`Crime_Date`)
ORDER BY
  DAYOFWEEK(`la_crime_data`.`Crime_Date`) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.131
  Output Similarity: 0.000
  Execution Time: 2.762 seconds

Test 131:
  NLQ: Give total crimes occurred in LA during each month of the year
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
    MONTH(Crime_Date) AS Month,
    COUNT(*) AS Crime_Count
FROM
    la_crime_data
GROUP BY
    MONTH(Crime_Date)
ORDER BY
    MONTH(Crime_Date);
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.212
  Output Similarity: 0.000
  Execution Time: 2.755 seconds

Test 132:
  NLQ: Give total crimes occurred in LA at each hour of the day
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  FLOOR(`la_crime_data`.`Crime_Time` / 100) + 1 AS `Hour`,
  COUNT(*) AS `Count`
FROM
  `la_crime_data`
GROUP BY
  `Hour`
ORDER BY
  `Hour` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.193
  Output Similarity: 0.000
  Execution Time: 2.758 seconds

Test 133:
  NLQ: Give total count of crimes in LA grouped by week
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(YEARWEEK(`la_crime_data`.`Crime_Date`), ' Sunday'),
    '%X%V %W'
  ) AS `Crime_Date`,
  count(distinct `la_crime_data`.`Report_#`) AS `count`
FROM
  `la_crime_data`
GROUP BY
  STR_TO_DATE(
    CONCAT(YEARWEEK(`la_crime_data`.`Crime_Date`), ' Sunday'),
    '%X%V %W'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(YEARWEEK(`la_crime_data`.`Crime_Date`), ' Sunday'),
    '%X%V %W'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.070
  Output Similarity: 0.000
  Execution Time: 2.759 seconds

Test 134:
  NLQ: Give total crimes occurred in New York on each day of the week
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(`nyc_crime_data`.`Crime_Date`) AS `Crime_Date`,
  COUNT(*) AS `count`
FROM
  `nyc_crime_data`
GROUP BY
  DAYOFWEEK(`nyc_crime_data`.`Crime_Date`)
ORDER BY
  DAYOFWEEK(`nyc_crime_data`.`Crime_Date`) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.133
  Output Similarity: 0.000
  Execution Time: 1.289 seconds

Test 135:
  NLQ: Give total crimes occurred in New York during each month of the year
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
    MONTH(Crime_Date) AS Month,
    COUNT(*) AS Crime_Count
FROM
    nyc_crime_data
GROUP BY
    MONTH(Crime_Date)
ORDER BY
    MONTH(Crime_Date);
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.218
  Output Similarity: 0.000
  Execution Time: 1.296 seconds

Test 136:
  NLQ: Give total crimes occurred in New York at each hour of the day
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  HOUR(`nyc_crime_data`.`Crime_Time`) + 1 AS `Hour`,
  COUNT(*) AS `Count`
FROM
  `nyc_crime_data`
GROUP BY
  `Hour`
ORDER BY
  `Hour` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.207
  Output Similarity: 0.000
  Execution Time: 1.289 seconds

Test 137:
  NLQ: Give total count of crimes in New York grouped by week since January 2023
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`nyc_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) AS `Crime_Date`,
  count(distinct `nyc_crime_data`.`Report_#`) AS `count`
FROM
  `nyc_crime_data`
WHERE
  `nyc_crime_data`.`Crime_Date` >= convert_tz(
    '2023-01-02 00:00:00.000',
    'America/New_York',
    @@session.time_zone
  )
GROUP BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`nyc_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`nyc_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.094
  Output Similarity: 0.000
  Execution Time: 1.290 seconds

Test 138:
  NLQ: Give total crimes occurred in Philly on each day of the week
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(`philly_crime_data`.`Crime_Date`) AS `Crime_Date`,
  COUNT(*) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  DAYOFWEEK(`philly_crime_data`.`Crime_Date`)
ORDER BY
  DAYOFWEEK(`philly_crime_data`.`Crime_Date`) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.140
  Output Similarity: 0.000
  Execution Time: 2.321 seconds

Test 139:
  NLQ: Give total crimes occurred in Philly during each month of the year
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
    MONTH(Crime_Date) AS Month,
    COUNT(*) AS Crime_Count
FROM
    philly_crime_data
GROUP BY
    MONTH(Crime_Date)
ORDER BY
    MONTH(Crime_Date);
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.235
  Output Similarity: 0.000
  Execution Time: 2.322 seconds

Test 140:
  NLQ: Give total crimes occurred in Philly at each hour of the day
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  HOUR(`philly_crime_data`.`Crime_Time`) + 1 AS `Hour`,
  COUNT(*) AS `Count`
FROM
  `philly_crime_data`
GROUP BY
  `Hour`
ORDER BY
  `Hour` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.220
  Output Similarity: 0.000
  Execution Time: 2.321 seconds

Test 141:
  NLQ: Give total count of crimes in Philly grouped by week
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`philly_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) AS `Crime_Date`,
  count(distinct `philly_crime_data`.`Crime_ID`) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`philly_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      YEARWEEK(`philly_crime_data`.`Crime_Date`),
      ' Sunday'
    ),
    '%X%V %W'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.075
  Output Similarity: 0.000
  Execution Time: 2.321 seconds

Test 142:
  NLQ: Give the amount of crimes in each area of Atlanta
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  `atlanta_crime_data`.`Area_Name` AS `Area_Name`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  `atlanta_crime_data`.`Area_Name`
ORDER BY
  `atlanta_crime_data`.`Area_Name` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.169
  Output Similarity: 0.000
  Execution Time: 0.895 seconds

Test 143:
  NLQ: Give the amount of crimes in each area of LA
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  `la_crime_data`.`Area_Name` AS `Area_Name`,
  COUNT(*) AS `count`
FROM
  `la_crime_data`
GROUP BY
  `la_crime_data`.`Area_Name`
ORDER BY
  `la_crime_data`.`Area_Name` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.160
  Output Similarity: 0.000
  Execution Time: 2.758 seconds

Test 144:
  NLQ: Give the amount of crimes in each area of New York
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  `nyc_crime_data`.`Area_Name` AS `Area_Name`,
  COUNT(*) AS `count`
FROM
  `nyc_crime_data`
GROUP BY
  `nyc_crime_data`.`Area_Name`
ORDER BY
  `nyc_crime_data`.`Area_Name` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.162
  Output Similarity: 0.000
  Execution Time: 1.290 seconds

Test 145:
  NLQ: Give the amount of crimes in each area of Philly
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10 AS `Area_#`,
  COUNT(*) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10
ORDER BY
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10 ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.135
  Output Similarity: 0.000
  Execution Time: 2.322 seconds

Test 146:
  NLQ: For each coordinate in latitude and longitude of Atlanta spaced by 0.01 degrees, give the most common crime type and its count
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  Latitude,
  Longitude,
  Most_Common_Crime_Type,
  count
FROM (
  SELECT
    (
      FLOOR(((`atlanta_crime_data`.`Latitude` - 33.64) / 0.01)) * 0.01
    ) + 33.64 AS Latitude,
    (
      FLOOR(((`atlanta_crime_data`.`Longitude` - -84.55) / 0.01)) * 0.01
    ) + -84.55 AS Longitude,
    Crime_Type AS Most_Common_Crime_Type,
    COUNT(*) AS count,
    ROW_NUMBER() OVER(PARTITION BY
      (
        FLOOR(((`atlanta_crime_data`.`Latitude` - 33.64) / 0.01)) * 0.01
      ) + 33.64,
      (
        FLOOR(((`atlanta_crime_data`.`Longitude` - -84.55) / 0.01)) * 0.01
      ) + -84.55
    ORDER BY COUNT(*) DESC
    ) AS crime_rank
  FROM
    `atlanta_crime_data`
  GROUP BY
    Latitude,
    Longitude,
    Crime_Type
) AS ranked_crimes
WHERE
  crime_rank = 1
ORDER BY
  Latitude ASC,
  Longitude ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.050
  Output Similarity: 0.000
  Execution Time: 0.900 seconds

Test 147:
  NLQ: For each coordinate in latitude and longitude of Atlanta spaced by 0.01 degrees, give the total crime count.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  (
    FLOOR(((`atlanta_crime_data`.`Latitude` - 33.64) / 0.01)) * 0.01
  ) + 33.64 AS `Latitude`,
  (
    FLOOR(((`atlanta_crime_data`.`Longitude` - -84.55) / 0.01)) * 0.01
  ) + -84.55 AS `Longitude`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  (
    FLOOR(((`atlanta_crime_data`.`Latitude` - 33.64) / 0.01)) * 0.01
  ) + 33.64,
  (
    FLOOR(((`atlanta_crime_data`.`Longitude` - -84.55) / 0.01)) * 0.01
  ) + -84.55
ORDER BY
  (
    FLOOR(((`atlanta_crime_data`.`Latitude` - 33.64) / 0.01)) * 0.01
  ) + 33.64 ASC,
  (
    FLOOR(((`atlanta_crime_data`.`Longitude` - -84.55) / 0.01)) * 0.01
  ) + -84.55 ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.055
  Output Similarity: 0.000
  Execution Time: 0.899 seconds

Test 148:
  NLQ: For each coordinate in latitude and longitude of LA spaced by 0.01 degrees, give the total crime count.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  FLOOR((`la_crime_data`.`Latitude` / 0.01)) * 0.01 AS `Latitude`,
  (
    FLOOR(((`la_crime_data`.`Longitude` - -118.66) / 0.01)) * 0.01
  ) + -118.66 AS `Longitude`,
  COUNT(*) AS `count`
FROM
  `la_crime_data`
GROUP BY
  FLOOR((`la_crime_data`.`Latitude` / 0.01)) * 0.01,
  (
    FLOOR(((`la_crime_data`.`Longitude` - -118.66) / 0.01)) * 0.01
  ) + -118.66
ORDER BY
  FLOOR((`la_crime_data`.`Latitude` / 0.01)) * 0.01 ASC,
  (
    FLOOR(((`la_crime_data`.`Longitude` - -118.66) / 0.01)) * 0.01
  ) + -118.66 ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.055
  Output Similarity: 0.000
  Execution Time: 2.765 seconds

Test 149:
  NLQ: For each coordinate in latitude and longitude of LA spaced by 0.01 degrees, give the most common crime type and its count
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  Latitude,
  Longitude,
  Most_Common_Crime_Type,
  count
FROM (
  SELECT
    FLOOR((`la_crime_data`.`Latitude` / 0.015)) * 0.015 AS Latitude,
    (
      FLOOR(((`la_crime_data`.`Longitude` - -118.66) / 0.015)) * 0.015
    ) + -118.66 AS Longitude,
    Crime_Type AS Most_Common_Crime_Type,
    COUNT(*) AS count,
    ROW_NUMBER() OVER(PARTITION BY
      FLOOR((`la_crime_data`.`Latitude` / 0.015)) * 0.015,
      (
        FLOOR(((`la_crime_data`.`Longitude` - -118.66) / 0.015)) * 0.015
      ) + -118.66
    ORDER BY COUNT(*) DESC
    ) AS crime_rank
  FROM
    `la_crime_data`
  GROUP BY
    Latitude,
    Longitude,
    Crime_Type
) AS ranked_crimes
WHERE
  crime_rank = 1
ORDER BY
  Latitude ASC,
  Longitude ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.046
  Output Similarity: 0.000
  Execution Time: 2.755 seconds

Test 150:
  NLQ: For each coordinate in latitude and longitude of New York spaced by 0.01 degrees, give the total crime count.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  (
    FLOOR(((`nyc_crime_data`.`Latitude` - 40.49) / 0.01)) * 0.01
  ) + 40.49 AS `Latitude`,
  (
    FLOOR(((`nyc_crime_data`.`Longitude` - -74.27) / 0.01)) * 0.01
  ) + -74.27 AS `Longitude`,
  COUNT(*) AS `count`
FROM
  `nyc_crime_data`
GROUP BY
  (
    FLOOR(((`nyc_crime_data`.`Latitude` - 40.49) / 0.01)) * 0.01
  ) + 40.49,
  (
    FLOOR(((`nyc_crime_data`.`Longitude` - -74.27) / 0.01)) * 0.01
  ) + -74.27
ORDER BY
  (
    FLOOR(((`nyc_crime_data`.`Latitude` - 40.49) / 0.01)) * 0.01
  ) + 40.49 ASC,
  (
    FLOOR(((`nyc_crime_data`.`Longitude` - -74.27) / 0.01)) * 0.01
  ) + -74.27 ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.051
  Output Similarity: 0.000
  Execution Time: 1.291 seconds

Test 151:
  NLQ: For each coordinate in latitude and longitude of New York spaced by 0.01 degrees, give the most common crime type and its count
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  Latitude,
  Longitude,
  Most_Common_Crime_Type,
  count
FROM (
  SELECT
    FLOOR((Latitude - 40.49) / 0.01) * 0.01 + 40.49 AS Latitude,
    FLOOR((Longitude - -74.27) / 0.01) * 0.01 - 74.27 AS Longitude,
    Crime_Type AS Most_Common_Crime_Type,
    COUNT(*) AS count,
    ROW_NUMBER() OVER(PARTITION BY
      FLOOR((Latitude - 40.49) / 0.01) * 0.01 + 40.49,
      FLOOR((Longitude - -74.27) / 0.01) * 0.01 - 74.27
    ORDER BY COUNT(*) DESC
    ) AS crime_rank
  FROM
    nyc_crime_data
  WHERE
    Latitude != 0
    AND Longitude != 0
  GROUP BY
    Latitude,
    Longitude,
    Crime_Type
) AS ranked_crimes
WHERE
  crime_rank = 1
ORDER BY
  Latitude ASC,
  Longitude ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.060
  Output Similarity: 0.000
  Execution Time: 1.297 seconds

Test 152:
  NLQ: For each coordinate in latitude and longitude of Philly spaced by 0.01 degrees, give the total crime count.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  (
    FLOOR(((`philly_crime_data`.`Latitude` - 39.86) / 0.01)) * 0.01
  ) + 39.86 AS `Latitude`,
  (
    FLOOR(((`philly_crime_data`.`Longitude` - -75.28) / 0.01)) * 0.01
  ) + -75.28 AS `Longitude`,
  COUNT(*) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  (
    FLOOR(((`philly_crime_data`.`Latitude` - 39.86) / 0.01)) * 0.01
  ) + 39.86,
  (
    FLOOR(((`philly_crime_data`.`Longitude` - -75.28) / 0.01)) * 0.01
  ) + -75.28
ORDER BY
  (
    FLOOR(((`philly_crime_data`.`Latitude` - 39.86) / 0.01)) * 0.01
  ) + 39.86 ASC,
  (
    FLOOR(((`philly_crime_data`.`Longitude` - -75.28) / 0.01)) * 0.01
  ) + -75.28 ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.054
  Output Similarity: 0.000
  Execution Time: 2.328 seconds

Test 153:
  NLQ: For each coordinate in latitude and longitude of Philly spaced by 0.01 degrees, give the most common crime type and its count
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
    Latitude,
    Longitude,
    Most_Common_Crime_Type,
    count
FROM (
    SELECT
        FLOOR((Latitude - 39.86) / 0.01) * 0.01 + 39.86 AS Latitude,
        FLOOR((Longitude + 75.28) / 0.01) * 0.01 - 75.28 AS Longitude,
        Crime_Type AS Most_Common_Crime_Type,
        COUNT(*) AS count,
        ROW_NUMBER() OVER(PARTITION BY
            FLOOR((Latitude - 39.86) / 0.01) * 0.01 + 39.86,
            FLOOR((Longitude + 75.28) / 0.01) * 0.01 - 75.28
            ORDER BY COUNT(*) DESC
        ) AS crime_rank
    FROM
        philly_crime_data
    WHERE
        Latitude != 0
        AND Longitude != 0
    GROUP BY
        FLOOR((Latitude - 39.86) / 0.01) * 0.01 + 39.86,
        FLOOR((Longitude + 75.28) / 0.01) * 0.01 - 75.28,
        Crime_Type
) AS ranked_crimes
WHERE
    crime_rank = 1
ORDER BY
    Latitude ASC,
    Longitude ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.067
  Output Similarity: 0.000
  Execution Time: 2.341 seconds

Test 154:
  NLQ: Give the total count of each crime type in Atlanta
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  `atlanta_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  `atlanta_crime_data`.`Crime_Type`
ORDER BY
  `atlanta_crime_data`.`Crime_Type` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.166
  Output Similarity: 0.000
  Execution Time: 0.904 seconds

Test 155:
  NLQ: For each crime type in Atlanta, give its total count, last reported date, last reported area, most common area for this crime type, and percentage increase in this crime type by week.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
    a.Crime_Type,
    COUNT(*) AS Total_Count,
    MAX(a.Crime_Date) AS Last_Date_Reported,
    MAX(a.Area_Name) AS Last_Area_Reported,
    ANY_VALUE(b.Most_Common_Area) AS Most_Prevalent_Area,
    IFNULL((SUM(CASE WHEN a.Crime_Date >= (SELECT MAX(Crime_Date) FROM atlanta_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) / COUNT(*)) * 100, 0) AS Crime_Increase_Proportion
FROM
    atlanta_crime_data a
LEFT JOIN (
    SELECT
        Crime_Type,
        Area_Name AS Most_Common_Area
    FROM (
        SELECT
            Crime_Type,
            Area_Name,
            ROW_NUMBER() OVER(PARTITION BY Crime_Type ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            atlanta_crime_data
        GROUP BY
            Crime_Type, Area_Name
    ) ranked_areas
    WHERE
        crime_rank = 1
) b ON a.Crime_Type = b.Crime_Type
GROUP BY
    a.Crime_Type
ORDER BY
    a.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.051
  Output Similarity: 0.000
  Execution Time: 0.902 seconds

Test 156:
  NLQ: Give the total count of each crime type in LA
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  `la_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `la_crime_data`
GROUP BY
  `la_crime_data`.`Crime_Type`
ORDER BY
  `la_crime_data`.`Crime_Type` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.156
  Output Similarity: 0.000
  Execution Time: 2.774 seconds

Test 157:
  NLQ: Give the total count of each crime type in New York
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  `nyc_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `nyc_crime_data`
GROUP BY
  `nyc_crime_data`.`Crime_Type`
ORDER BY
  `nyc_crime_data`.`Crime_Type` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.158
  Output Similarity: 0.000
  Execution Time: 1.300 seconds

Test 158:
  NLQ: Give the total count of each crime type in Philly
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  `philly_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  `philly_crime_data`.`Crime_Type`
ORDER BY
  `philly_crime_data`.`Crime_Type` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.164
  Output Similarity: 0.000
  Execution Time: 2.338 seconds

Test 159:
  NLQ: For each area in Atlanta, give count of each crime type.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  `atlanta_crime_data`.`Area_Name` AS `Area_Name`,
  `atlanta_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  `atlanta_crime_data`.`Area_Name`,
  `atlanta_crime_data`.`Crime_Type`
ORDER BY
  `atlanta_crime_data`.`Area_Name` ASC,
  `atlanta_crime_data`.`Crime_Type` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.102
  Output Similarity: 0.000
  Execution Time: 0.899 seconds

Test 160:
  NLQ: For each area in New York, give count of each crime type.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  `nyc_crime_data`.`Crime_Type` AS `Crime_Type`,
  `nyc_crime_data`.`Area_Name` AS `Area_Name`,
  COUNT(*) AS `count`
FROM
  `nyc_crime_data`
GROUP BY
  `nyc_crime_data`.`Crime_Type`,
  `nyc_crime_data`.`Area_Name`
ORDER BY
  `nyc_crime_data`.`Crime_Type` ASC,
  `nyc_crime_data`.`Area_Name` ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.098
  Output Similarity: 0.000
  Execution Time: 1.293 seconds

Test 161:
  NLQ: For each area in Philly, give count of each crime type.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  `philly_crime_data`.`Crime_Type` AS `Crime_Type`,
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10 AS `Area_#`,
  COUNT(*) AS `count`
FROM
  `philly_crime_data`
GROUP BY
  `philly_crime_data`.`Crime_Type`,
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10
ORDER BY
  `philly_crime_data`.`Crime_Type` ASC,
  FLOOR((`philly_crime_data`.`Area_#` / 10)) * 10 ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.088
  Output Similarity: 0.000
  Execution Time: 2.331 seconds

Test 162:
  NLQ: Give count of each crime type for each day of the week in Atlanta.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(acd.Crime_Date) AS Crime_Day_Number,
  DAYNAME(acd.Crime_Date) AS Crime_Day_Name,
  acd.Crime_Type AS Crime_Type,
  COUNT(*) AS Crime_Count
FROM
  atlanta_crime_data acd
WHERE
  DAYOFWEEK(acd.Crime_Date) IS NOT NULL
GROUP BY
  DAYOFWEEK(acd.Crime_Date),
  DAYNAME(acd.Crime_Date),
  acd.Crime_Type
ORDER BY
  Crime_Day_Number,
  acd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.149
  Output Similarity: 0.000
  Execution Time: 0.898 seconds

Test 163:
  NLQ: Give count of each crime type for each hour of the day in Atlanta.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
  CASE
    WHEN HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s')) = 0 THEN 24
    ELSE HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s'))
  END AS `Crime_Hour`,
  `atlanta_crime_data`.`Crime_Type` AS `Crime_Type`,
  COUNT(*) AS `count`
FROM
  `atlanta_crime_data`
GROUP BY
  CASE
    WHEN HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s')) = 0 THEN 24
    ELSE HOUR(STR_TO_DATE(`atlanta_crime_data`.`Crime_Time`, '%H:%i:%s'))
  END,
  `atlanta_crime_data`.`Crime_Type`
ORDER BY
  `Crime_Hour` ASC,
  `Crime_Type` ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.062
  Output Similarity: 0.000
  Execution Time: 0.898 seconds

Test 164:
  NLQ: Give count of each crime type for each month in Atlanta.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
    MONTH(acd.Crime_Date) AS Month,
    acd.Crime_Type AS Crime_Type,
    COUNT(*) AS Crime_Count
FROM
    atlanta_crime_data acd
GROUP BY
    MONTH(acd.Crime_Date),
    acd.Crime_Type
ORDER BY
    MONTH(acd.Crime_Date),
    acd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.153
  Output Similarity: 0.000
  Execution Time: 0.899 seconds

Test 165:
  NLQ: Give count of each crime type for each day of the week in New York.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(ncd.Crime_Date) AS Crime_Day_Number,
  DAYNAME(ncd.Crime_Date) AS Crime_Day_Name,
  ncd.Crime_Type AS Crime_Type,
  COUNT(*) AS Crime_Count
FROM
  nyc_crime_data ncd
WHERE
  DAYOFWEEK(ncd.Crime_Date) IS NOT NULL
GROUP BY
  DAYOFWEEK(ncd.Crime_Date),
  DAYNAME(ncd.Crime_Date),
  ncd.Crime_Type
ORDER BY
  Crime_Day_Number,
  ncd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.134
  Output Similarity: 0.000
  Execution Time: 1.300 seconds

Test 166:
  NLQ: Give count of each crime type for each hour of the day in New York.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
  HOUR(ncd.Crime_Time) + 1 AS Hour,
  ncd.Crime_Type AS Crime_Type,
  COUNT(*) AS Count
FROM
  nyc_crime_data ncd
GROUP BY
  Hour,
  ncd.Crime_Type
ORDER BY
  Hour ASC,
  ncd.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.160
  Output Similarity: 0.000
  Execution Time: 1.293 seconds

Test 167:
  NLQ: Give count of each crime type for each month in New York.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
    MONTH(ncd.Crime_Date) AS Month,
    ncd.Crime_Type AS Crime_Type,
    COUNT(*) AS Crime_Count
FROM
    nyc_crime_data ncd
GROUP BY
    MONTH(ncd.Crime_Date),
    ncd.Crime_Type
ORDER BY
    MONTH(ncd.Crime_Date),
    ncd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.137
  Output Similarity: 0.000
  Execution Time: 1.296 seconds

Test 168:
  NLQ: Give count of each crime type for each day of the week in Philly.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(pcd.Crime_Date) AS Crime_Day_Number,
  DAYNAME(pcd.Crime_Date) AS Crime_Day_Name,
  pcd.Crime_Type AS Crime_Type,
  COUNT(*) AS Crime_Count
FROM
  philly_crime_data pcd
GROUP BY
  DAYOFWEEK(pcd.Crime_Date),
  DAYNAME(pcd.Crime_Date),
  pcd.Crime_Type
ORDER BY
  Crime_Day_Number,
  pcd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.108
  Output Similarity: 0.000
  Execution Time: 2.323 seconds

Test 169:
  NLQ: Give count of each crime type for each hour of the day in Philly.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
  HOUR(pcd.Crime_Time) + 1 AS Hour,
  pcd.Crime_Type AS Crime_Type,
  COUNT(*) AS Count
FROM
  philly_crime_data pcd
GROUP BY
  Hour,
  pcd.Crime_Type
ORDER BY
  Hour ASC,
  pcd.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.174
  Output Similarity: 0.000
  Execution Time: 2.322 seconds

Test 170:
  NLQ: Give count of each crime type for each month in Philly.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
    MONTH(pcd.Crime_Date) AS Month,
    pcd.Crime_Type AS Crime_Type,
    COUNT(*) AS Crime_Count
FROM
    philly_crime_data pcd
GROUP BY
    MONTH(pcd.Crime_Date),
    pcd.Crime_Type
ORDER BY
    MONTH(pcd.Crime_Date),
    pcd.Crime_Type;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.150
  Output Similarity: 0.000
  Execution Time: 2.328 seconds

Test 171:
  NLQ: For each area of Atlanta give the total crime count, last reported date of any crime and the type of crime, most common crime type and weekly increase in crimes by percentage.
  Predicted SQL: SELECT * FROM atlanta_crime_data;
  Ground Truth SQL: SELECT
    c.Area_Name,
    c.Cumulative_Crime_Count,
    c.Latest_Crime_Date,
    c.Latest_Crime_Type,
    IFNULL(mct.Most_Common_Crime_Type, 'Unknown') AS Most_Common_Crime_Type,
    IFNULL((c.Crime_Change / c.Cumulative_Crime_Count) * 100, 0) AS Crime_Change_Last_Week_Proportion
FROM (
    SELECT
        Area_Name,
        COUNT(*) AS Cumulative_Crime_Count,
        latest_date AS Latest_Crime_Date,
       SUBSTRING_INDEX(GROUP_CONCAT(Crime_Type ORDER BY Crime_Date DESC), ',', 1) AS Latest_Crime_Type,
        SUM(CASE WHEN Crime_Date >= latest_date - INTERVAL 1 WEEK THEN 1 ELSE 0 END) AS Crime_Change
    FROM
        atlanta_crime_data
    CROSS JOIN (SELECT MAX(Crime_Date) AS latest_date FROM atlanta_crime_data) AS max_date
    GROUP BY
        Area_Name, latest_date
) c
LEFT JOIN (
    SELECT
        Area_Name,
        Most_Common_Crime_Type
    FROM (
        SELECT
            Area_Name,
            Crime_Type AS Most_Common_Crime_Type,
            ROW_NUMBER() OVER(PARTITION BY Area_Name ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            atlanta_crime_data
        GROUP BY
            Area_Name, Crime_Type
    ) ranked_crimes
    WHERE
        crime_rank = 1
) mct ON c.Area_Name = mct.Area_Name
ORDER BY
    c.Area_Name ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.034
  Output Similarity: 0.000
  Execution Time: 0.898 seconds

Test 172:
  NLQ: For each area of LA give the total crime count, last reported date of any crime and the type of crime, most common crime type and weekly increase in crimes by percentage.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
    c.Area_Name,
    c.Cumulative_Crime_Count,
    c.Latest_Crime_Date,
    c.Latest_Crime_Type,
    mct.Most_Common_Crime_Type,
    IFNULL((c.Crime_Change / c.Cumulative_Crime_Count) * 100, 0) AS Crime_Change_Last_Week_Proportion
FROM (
    SELECT
        Area_Name,
        COUNT(*) AS Cumulative_Crime_Count,
        MAX(Crime_Date) AS Latest_Crime_Date,
       SUBSTRING_INDEX(GROUP_CONCAT(Crime_Type ORDER BY Crime_Date DESC), ',', 1) AS Latest_Crime_Type,
        SUM(CASE WHEN Crime_Date >= CURDATE() - INTERVAL 1 WEEK THEN 1 ELSE 0 END) AS Crime_Change
    FROM
        la_crime_data
    GROUP BY
        Area_Name
) c
LEFT JOIN (
    SELECT
        Area_Name,
        Most_Common_Crime_Type
    FROM (
        SELECT
            Area_Name,
            Crime_Type AS Most_Common_Crime_Type,
            ROW_NUMBER() OVER(PARTITION BY Area_Name ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            la_crime_data
        GROUP BY
            Area_Name, Crime_Type
    ) ranked_crimes
    WHERE
        crime_rank = 1
) mct ON c.Area_Name = mct.Area_Name
ORDER BY
    c.Area_Name ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.034
  Output Similarity: 0.000
  Execution Time: 2.759 seconds

Test 173:
  NLQ: For each area of New York give the total crime count, last reported date of any crime and the type of crime, most common crime type and weekly increase in crimes by percentage.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
    c.Area_Name,
    c.Cumulative_Crime_Count,
    c.Latest_Crime_Date,
    c.Latest_Crime_Type,
    mct.Most_Common_Crime_Type,
    IFNULL((c.Crime_Change / c.Cumulative_Crime_Count) * 100, 0) AS Crime_Change_Last_Week_Proportion
FROM (
    SELECT
        Area_Name,
        COUNT(*) AS Cumulative_Crime_Count,
        MAX(Crime_Date) AS Latest_Crime_Date,
       SUBSTRING_INDEX(GROUP_CONCAT(Crime_Type ORDER BY Crime_Date DESC), ',', 1) AS Latest_Crime_Type,
        SUM(CASE WHEN Crime_Date >= (SELECT MAX(Crime_Date) FROM nyc_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) AS Crime_Change
    FROM
        nyc_crime_data
    GROUP BY
        Area_Name
) c
LEFT JOIN (
    SELECT
        Area_Name,
        Most_Common_Crime_Type
    FROM (
        SELECT
            Area_Name,
            Crime_Type AS Most_Common_Crime_Type,
            ROW_NUMBER() OVER(PARTITION BY Area_Name ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            nyc_crime_data
        GROUP BY
            Area_Name, Crime_Type
    ) ranked_crimes
    WHERE
        crime_rank = 1
) mct ON c.Area_Name = mct.Area_Name
ORDER BY
    c.Area_Name ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.034
  Output Similarity: 0.000
  Execution Time: 1.290 seconds

Test 174:
  NLQ: For each area of Philly give the total crime count, last reported date of any crime and the type of crime, most common crime type and weekly increase in crimes by percentage.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
    CONCAT(FLOOR(c.`Area_#` / 10) * 10, ' - ', FLOOR(c.`Area_#` / 10) * 10 + 9) AS Area_Num_Range,
    SUM(c.Cumulative_Crime_Count) AS Cumulative_Crime_Count,
    MAX(c.Latest_Crime_Date) AS Latest_Crime_Date,
    MAX(c.Latest_Crime_Type) AS Latest_Crime_Type,
    MAX(mct.Most_Common_Crime_Type) AS Most_Common_Crime_Type,
    IFNULL((SUM(c.Crime_Change) / SUM(c.Cumulative_Crime_Count)) * 100, 0) AS Crime_Change_Last_Week_Proportion
FROM (
    SELECT
        `Area_#`,
        COUNT(*) AS Cumulative_Crime_Count,
        MAX(Crime_Date) AS Latest_Crime_Date,
       SUBSTRING_INDEX(GROUP_CONCAT(Crime_Type ORDER BY Crime_Date DESC), ',', 1) AS Latest_Crime_Type,
        SUM(CASE WHEN Crime_Date >= (SELECT MAX(Crime_Date) FROM philly_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) AS Crime_Change
    FROM
        philly_crime_data
    GROUP BY
        `Area_#`
) c
LEFT JOIN (
    SELECT
        `Area_#`,
        Most_Common_Crime_Type
    FROM (
        SELECT
            `Area_#`,
            Crime_Type AS Most_Common_Crime_Type,
            ROW_NUMBER() OVER(PARTITION BY `Area_#` ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            philly_crime_data
        GROUP BY
            `Area_#`, Crime_Type
    ) ranked_crimes
    WHERE
        crime_rank = 1
) mct ON c.`Area_#` = mct.`Area_#`
GROUP BY
    CONCAT(FLOOR(c.`Area_#` / 10) * 10, ' - ', FLOOR(c.`Area_#` / 10) * 10 + 9)
ORDER BY
    CONCAT(FLOOR(c.`Area_#` / 10) * 10, ' - ', FLOOR(c.`Area_#` / 10) * 10 + 9);
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.028
  Output Similarity: 0.000
  Execution Time: 2.321 seconds

Test 175:
  NLQ: For each crime type in LA, give its total count, last reported date, last reported area, most common area for this crime type, and percentage increase in this crime type by week.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
    a.Crime_Type,
    COUNT(*) AS Total_Count,
    MAX(a.Crime_Date) AS Last_Date_Reported,
    MAX(a.Area_Name) AS Last_Area_Reported,
    ANY_VALUE(b.Most_Common_Area) AS Most_Prevalent_Area,
    IFNULL((SUM(CASE WHEN a.Crime_Date >= (SELECT MAX(Crime_Date) FROM la_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) / COUNT(*)) * 100, 0) AS Crime_Increase_Proportion
FROM
    la_crime_data a
LEFT JOIN (
    SELECT
        Crime_Type,
        Area_Name AS Most_Common_Area
    FROM (
        SELECT
            Crime_Type,
            Area_Name,
            ROW_NUMBER() OVER(PARTITION BY Crime_Type ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            la_crime_data
        GROUP BY
            Crime_Type, Area_Name
    ) ranked_areas
    WHERE
        crime_rank = 1
) b ON a.Crime_Type = b.Crime_Type
GROUP BY
    a.Crime_Type
ORDER BY
    a.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.044
  Output Similarity: 0.000
  Execution Time: 2.757 seconds

Test 176:
  NLQ: For each crime type in New York, give its total count, last reported date, last reported area, most common area for this crime type, and percentage increase in this crime type by week.
  Predicted SQL: SELECT * FROM nyc_crime_data;
  Ground Truth SQL: SELECT
    a.Crime_Type,
    COUNT(*) AS Total_Count,
    MAX(a.Crime_Date) AS Last_Date_Reported,
    MAX(a.Area_Name) AS Last_Area_Reported,
    ANY_VALUE(b.Most_Common_Area) AS Most_Prevalent_Area,
    IFNULL((SUM(CASE WHEN a.Crime_Date >= (SELECT MAX(Crime_Date) FROM nyc_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) / COUNT(*)) * 100, 0) AS Crime_Increase_Proportion
FROM
    nyc_crime_data a
LEFT JOIN (
    SELECT
        Crime_Type,
        Area_Name AS Most_Common_Area
    FROM (
        SELECT
            Crime_Type,
            Area_Name,
            ROW_NUMBER() OVER(PARTITION BY Crime_Type ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            nyc_crime_data
        GROUP BY
            Crime_Type, Area_Name
    ) ranked_areas
    WHERE
        crime_rank = 1
) b ON a.Crime_Type = b.Crime_Type
GROUP BY
    a.Crime_Type
ORDER BY
    a.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.045
  Output Similarity: 0.000
  Execution Time: 1.293 seconds

Test 177:
  NLQ: For each crime type in Philly, give its total count, last reported date, last reported area, most common area for this crime type, and percentage increase in this crime type by week.
  Predicted SQL: SELECT * FROM philly_crime_data;
  Ground Truth SQL: SELECT
    a.Crime_Type,
    COUNT(*) AS Total_Count,
    MAX(a.Crime_Date) AS Last_Date_Reported,
    MAX(a.`Area_#`) AS Last_Area_Reported,
    ANY_VALUE(b.Most_Common_Area) AS Most_Prevalent_Area,
    IFNULL((SUM(CASE WHEN a.Crime_Date >= (SELECT MAX(Crime_Date) FROM philly_crime_data) - INTERVAL 1 WEEK THEN 1 ELSE 0 END) / COUNT(*)) * 100, 0) AS Crime_Increase_Proportion
FROM
    philly_crime_data a
LEFT JOIN (
    SELECT
        Crime_Type,
        `Area_#` AS Most_Common_Area
    FROM (
        SELECT
            Crime_Type,
            `Area_#`,
            ROW_NUMBER() OVER(PARTITION BY Crime_Type ORDER BY COUNT(*) DESC) AS crime_rank
        FROM
            philly_crime_data
        GROUP BY
            Crime_Type, `Area_#`
    ) ranked_areas
    WHERE
        crime_rank = 1
) b ON a.Crime_Type = b.Crime_Type
GROUP BY
    a.Crime_Type
ORDER BY
    a.Crime_Type ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.050
  Output Similarity: 0.000
  Execution Time: 2.321 seconds

Test 178:
  NLQ: Give count of each crime type for each month in LA.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
    MONTH(lcd.Crime_Date) AS Month,
    CASE 
        WHEN lcd.Crime_Type IN ('ASSAULT WITH DEADLY WEAPON', 'AGGRAVATED ASSAULT') THEN 'ASSAULT WITH DEADLY WEAPON, AGGRAVATED ASSAULT'
        WHEN lcd.Crime_Type = 'BATTERY - SIMPLE ASSAULT' THEN 'BATTERY - SIMPLE ASSAULT'
        WHEN lcd.Crime_Type = 'BURGLARY' THEN 'BURGLARY'
        WHEN lcd.Crime_Type = 'BURGLARY FROM VEHICLE' THEN 'BURGLARY FROM VEHICLE'
        WHEN lcd.Crime_Type = 'INTIMATE PARTNER - SIMPLE ASSAULT' THEN 'INTIMATE PARTNER - SIMPLE ASSAULT'
        WHEN lcd.Crime_Type = 'ROBBERY' THEN 'ROBBERY'
        WHEN lcd.Crime_Type = 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)' THEN 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)'
        WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)' THEN 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)'
        WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)' THEN 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)'
        WHEN lcd.Crime_Type = 'THEFT OF IDENTITY' THEN 'THEFT OF IDENTITY'
        WHEN lcd.Crime_Type = 'THEFT PLAIN - PETTY ($950 & UNDER)' THEN 'THEFT PLAIN - PETTY ($950 & UNDER)'
        WHEN lcd.Crime_Type = 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD' THEN 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD'
        WHEN lcd.Crime_Type = 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)' THEN 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)'
        WHEN lcd.Crime_Type = 'VANDALISM - MISDEMEANOR ($399 OR UNDER)' THEN 'VANDALISM - MISDEMEANOR ($399 OR UNDER)'
        WHEN lcd.Crime_Type = 'VEHICLE - STOLEN' THEN 'VEHICLE - STOLEN'
        ELSE 'Other'
    END AS Crime_Type_Grouped,
    COUNT(*) AS Crime_Count
FROM
    la_crime_data lcd
GROUP BY
    Month,
    Crime_Type_Grouped
ORDER BY
    Month,
    Crime_Type_Grouped;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.017
  Output Similarity: 0.000
  Execution Time: 2.762 seconds

Test 179:
  NLQ: Give count of each crime type for each hour of the day in LA.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  FLOOR(lcd.Crime_Time / 100) + 1 AS Hour,
  CASE 
    WHEN lcd.Crime_Type IN ('ASSAULT WITH DEADLY WEAPON', 'AGGRAVATED ASSAULT') THEN 'ASSAULT WITH DEADLY WEAPON, AGGRAVATED ASSAULT'
    WHEN lcd.Crime_Type = 'BATTERY - SIMPLE ASSAULT' THEN 'BATTERY - SIMPLE ASSAULT'
    WHEN lcd.Crime_Type = 'BURGLARY' THEN 'BURGLARY'
    WHEN lcd.Crime_Type = 'BURGLARY FROM VEHICLE' THEN 'BURGLARY FROM VEHICLE'
    WHEN lcd.Crime_Type = 'INTIMATE PARTNER - SIMPLE ASSAULT' THEN 'INTIMATE PARTNER - SIMPLE ASSAULT'
    WHEN lcd.Crime_Type = 'ROBBERY' THEN 'ROBBERY'
    WHEN lcd.Crime_Type = 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)' THEN 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)' THEN 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)'
    WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)' THEN 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT OF IDENTITY' THEN 'THEFT OF IDENTITY'
    WHEN lcd.Crime_Type = 'THEFT PLAIN - PETTY ($950 & UNDER)' THEN 'THEFT PLAIN - PETTY ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD' THEN 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD'
    WHEN lcd.Crime_Type = 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)' THEN 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)'
    WHEN lcd.Crime_Type = 'VANDALISM - MISDEMEANOR ($399 OR UNDER)' THEN 'VANDALISM - MISDEMEANOR ($399 OR UNDER)'
    WHEN lcd.Crime_Type = 'VEHICLE - STOLEN' THEN 'VEHICLE - STOLEN'
    ELSE 'Other'
  END AS Crime_Type_Grouped,
  COUNT(*) AS Count
FROM
  la_crime_data lcd
GROUP BY
  Hour,
  Crime_Type_Grouped
ORDER BY
  Hour ASC,
  Crime_Type_Grouped ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.016
  Output Similarity: 0.000
  Execution Time: 2.756 seconds

Test 180:
  NLQ: Give count of each crime type for each day of the week in LA.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  DAYOFWEEK(lcd.Crime_Date) AS Crime_Day_Number,
  DAYNAME(lcd.Crime_Date) AS Crime_Day_Name,
  CASE 
    WHEN lcd.Crime_Type IN ('ASSAULT WITH DEADLY WEAPON', 'AGGRAVATED ASSAULT') THEN 'ASSAULT WITH DEADLY WEAPON, AGGRAVATED ASSAULT'
    WHEN lcd.Crime_Type = 'BATTERY - SIMPLE ASSAULT' THEN 'BATTERY - SIMPLE ASSAULT'
    WHEN lcd.Crime_Type = 'BURGLARY' THEN 'BURGLARY'
    WHEN lcd.Crime_Type = 'BURGLARY FROM VEHICLE' THEN 'BURGLARY FROM VEHICLE'
    WHEN lcd.Crime_Type = 'INTIMATE PARTNER - SIMPLE ASSAULT' THEN 'INTIMATE PARTNER - SIMPLE ASSAULT'
    WHEN lcd.Crime_Type = 'ROBBERY' THEN 'ROBBERY'
    WHEN lcd.Crime_Type = 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)' THEN 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)' THEN 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)'
    WHEN lcd.Crime_Type = 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)' THEN 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT OF IDENTITY' THEN 'THEFT OF IDENTITY'
    WHEN lcd.Crime_Type = 'THEFT PLAIN - PETTY ($950 & UNDER)' THEN 'THEFT PLAIN - PETTY ($950 & UNDER)'
    WHEN lcd.Crime_Type = 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD' THEN 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD'
    WHEN lcd.Crime_Type = 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)' THEN 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)'
    WHEN lcd.Crime_Type = 'VANDALISM - MISDEMEANOR ($399 OR UNDER)' THEN 'VANDALISM - MISDEMEANOR ($399 OR UNDER)'
    WHEN lcd.Crime_Type = 'VEHICLE - STOLEN' THEN 'VEHICLE - STOLEN'
    ELSE 'Other'
  END AS Crime_Type_Grouped,
  COUNT(*) AS Crime_Count
FROM
  la_crime_data lcd
GROUP BY
  Crime_Day_Number,
  Crime_Day_Name,
  Crime_Type_Grouped
ORDER BY
  Crime_Day_Number,
  Crime_Type_Grouped;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.016
  Output Similarity: 0.000
  Execution Time: 2.759 seconds

Test 181:
  NLQ: For each area in LA, give count of each crime type.
  Predicted SQL: SELECT * FROM la_crime_data;
  Ground Truth SQL: SELECT
  `la_crime_data`.`Area_Name` AS `Area_Name`,
  CASE 
    WHEN `la_crime_data`.`Crime_Type` IN ('ASSAULT WITH DEADLY WEAPON', 'AGGRAVATED ASSAULT') THEN 'ASSAULT WITH DEADLY WEAPON, AGGRAVATED ASSAULT'
    WHEN `la_crime_data`.`Crime_Type` = 'BATTERY - SIMPLE ASSAULT' THEN 'BATTERY - SIMPLE ASSAULT'
    WHEN `la_crime_data`.`Crime_Type` = 'BURGLARY' THEN 'BURGLARY'
    WHEN `la_crime_data`.`Crime_Type` = 'BURGLARY FROM VEHICLE' THEN 'BURGLARY FROM VEHICLE'
    WHEN `la_crime_data`.`Crime_Type` = 'INTIMATE PARTNER - SIMPLE ASSAULT' THEN 'INTIMATE PARTNER - SIMPLE ASSAULT'
    WHEN `la_crime_data`.`Crime_Type` = 'ROBBERY' THEN 'ROBBERY'
    WHEN `la_crime_data`.`Crime_Type` = 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)' THEN 'SHOPLIFTING - PETTY THEFT ($950 & UNDER)'
    WHEN `la_crime_data`.`Crime_Type` = 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)' THEN 'THEFT FROM MOTOR VEHICLE - GRAND ($950.01 AND OVER)'
    WHEN `la_crime_data`.`Crime_Type` = 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)' THEN 'THEFT FROM MOTOR VEHICLE - PETTY ($950 & UNDER)'
    WHEN `la_crime_data`.`Crime_Type` = 'THEFT OF IDENTITY' THEN 'THEFT OF IDENTITY'
    WHEN `la_crime_data`.`Crime_Type` = 'THEFT PLAIN - PETTY ($950 & UNDER)' THEN 'THEFT PLAIN - PETTY ($950 & UNDER)'
    WHEN `la_crime_data`.`Crime_Type` = 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD' THEN 'THEFT-GRAND ($950.01 & OVER)EXCPT,GUNS,FOWL,LIVESTK,PROD'
    WHEN `la_crime_data`.`Crime_Type` = 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)' THEN 'VANDALISM - FELONY ($400 & OVER, ALL CHURCH VANDALISMS)'
    WHEN `la_crime_data`.`Crime_Type` = 'VANDALISM - MISDEMEANOR ($399 OR UNDER)' THEN 'VANDALISM - MISDEMEANOR ($399 OR UNDER)'
    WHEN `la_crime_data`.`Crime_Type` = 'VEHICLE - STOLEN' THEN 'VEHICLE - STOLEN'
    ELSE 'Other'
  END AS `Crime_Type_Grouped`,
  COUNT(*) AS `Count`
FROM
  `la_crime_data`
GROUP BY
  `Area_Name`,
  `Crime_Type_Grouped`
ORDER BY
  `Area_Name` ASC,
  `Crime_Type_Grouped` ASC;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.015
  Output Similarity: 0.000
  Execution Time: 2.757 seconds

Test 182:
  NLQ: Get year-on-year change in GRAPI, where GRAPI is gross rent as percentage of household income.
  Predicted SQL: SELECT * FROM housing_gross_rent_percent;
  Ground Truth SQL: select str_to_date(concat(year,'-01-01'),'%Y-%m-%d') as `Year`, sum(number_of_units*(income_percent_max+income_percent_min)/2)/sum(number_of_units) as `GRAPI`
from housing_gross_rent_percent
group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.200
  Output Similarity: 0.000
  Execution Time: 0.050 seconds

Test 183:
  NLQ: Get year-on-year change in SMOCAPI, where SMOCAPI is selected monthly home-ownership costs as a percent of household income
  Predicted SQL: SELECT * FROM household_income_percent_with_mortgage;
  Ground Truth SQL: select str_to_date(concat(year,'-01-01'),'%Y-%m-%d') as `Year`, sum(number_of_units*(income_percent_max+income_percent_min)/2)/sum(number_of_units) as `SMOCAPI`
from household_income_percent_with_mortgage
group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.242
  Output Similarity: 0.000
  Execution Time: 0.043 seconds

Test 184:
  NLQ: For year 2017, get zipcodes in Georgia where SMOCAPI is greater than 28.
  Predicted SQL: SELECT * FROM household_income_percent_without_mortgage;
  Ground Truth SQL: select substring(household_income_percent_with_mortgage.zipcode, 7, 10) as zcta, sum(number_of_units*(income_percent_min+income_percent_max)/2)/sum(number_of_units) as `Change in monthly home-ownership costs as a percentage of household income` from household_income_percent_with_mortgage 
where year=2017
group by household_income_percent_with_mortgage.zipcode
having `Change in monthly home-ownership costs as a percentage of household income` > 28;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.124
  Output Similarity: 0.000
  Execution Time: 0.059 seconds

Test 185:
  NLQ: For year 2017, get zipcodes in Georgia where GRAPI is greater than or equal to 30.
  Predicted SQL: SELECT * FROM housing_gross_rent_percent;
  Ground Truth SQL: select substring(housing_gross_rent_percent.zipcode, 7, 10) as zcta, sum(number_of_units*(income_percent_min+income_percent_max)/2)/sum(number_of_units) as `Gross rent percent` 
from housing_gross_rent_percent
where year=2017
group by zipcode
having `Gross rent percent` >= 30;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.149
  Output Similarity: 0.000
  Execution Time: 0.051 seconds

Test 186:
  NLQ: For year 2022, get zipcodes in Georgia where GRAPI is greater than 30.
  Predicted SQL: SELECT * FROM housing_gross_rent_percent;
  Ground Truth SQL: select substring(housing_gross_rent_percent.zipcode, 7, 10) as zcta, sum(number_of_units*(income_percent_min+income_percent_max)/2)/sum(number_of_units) as `Gross rent percent` 
from housing_gross_rent_percent
where year=2022
group by zipcode
having `Gross rent percent` > 30;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.149
  Output Similarity: 0.000
  Execution Time: 0.050 seconds

Test 187:
  NLQ: Select share of each fuel source for heating in year 2022.
  Predicted SQL: SELECT * FROM housing_heating_fuel;
  Ground Truth SQL: select year, (sum(utility_gas)/(sum(total_heating_units)))*100 as 'utility_gas', 
(sum(bottled_tank_or_LP_gas)/(sum(total_heating_units)))*100 as 'bottled_tank_or_LP_gas', 
(sum(electricity)/(sum(total_heating_units)))*100 as 'electricity', 
(sum(fuel_oil_kerosene)/(sum(total_heating_units)))*100 as 'fuel_oil_kerosene', 
(sum(coal_or_coke)/(sum(total_heating_units)))*100 as 'coal_or_coke',
(sum(wood)/(sum(total_heating_units)))*100 as 'wood', 
(sum(solar_energy)/(sum(total_heating_units)))*100 as 'solar_energy',
(sum(utility_gas)/(sum(total_heating_units)))*100 as 'utility_gas', 
(sum(no_fuel_used)/(sum(total_heating_units)))*100 as 'no_fuel_used'
from housing_heating_fuel 
where year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.051
  Output Similarity: 0.000
  Execution Time: 0.015 seconds

Test 188:
  NLQ: For the year 2022, select zipcodes in Georgia where Home-ownership costs as a %age of household income is more than 28%
  Predicted SQL: SELECT * FROM household_income_percent_with_mortgage;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, sum(number_of_units*(income_percent_min+income_percent_max)/2)/sum(number_of_units) as `Monthly home-ownership costs as a percentage of household income` from household_income_percent_with_mortgage where year=2022 group by zipcode having `Monthly home-ownership costs as a percentage of household income` >= 30;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.150
  Output Similarity: 0.000
  Execution Time: 0.042 seconds

Test 189:
  NLQ: For each zipcode, get count of units with and without mortgage in year 2022.
  Predicted SQL: SELECT * FROM housing_mortgage;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, units_with_mortgage, units_without_mortgage
from housing_mortgage where year=2022
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.236
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 190:
  NLQ: Get count of units with and without mortgage averaged over years.
  Predicted SQL: SELECT * FROM housing_mortgage;
  Ground Truth SQL: select year, avg(units_with_mortgage) as 'units_with_mortgage', avg(units_without_mortgage) as 'units_without_mortgage'
from housing_mortgage
group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.192
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 191:
  NLQ: Get count of units with and without mortgage for year 2022.
  Predicted SQL: SELECT * FROM housing_mortgage;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, units_with_mortgage, units_without_mortgage
from housing_mortgage where year=2022
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.236
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 192:
  NLQ: Get average house price for each zip code in a given year.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select substring(housing_value.zipcode, 7, 10) as zcta, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as housing_value_weighted_avg
from housing_value where year={{year}} group by zipcode
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.110
  Output Similarity: 0.000
  Execution Time: 0.071 seconds

Test 193:
  NLQ: Get median housing value by zipcode.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: WITH CumulativeUnits AS (
    SELECT
        zipcode,
        house_value_min,
        house_value_max,
        number_of_units,
        SUM(number_of_units) OVER (PARTITION BY zipcode ORDER BY house_value_max) AS cumulative_units
    FROM
        housing_value
),
TotalUnits AS (
    SELECT
        zipcode,
        SUM(number_of_units) AS total_units
    FROM
        housing_value
    GROUP BY
        zipcode
)
SELECT
    substring(t.zipcode, 7, 10) as zcta,
    CASE
        WHEN t.total_units % 2 = 1 THEN
            (SELECT (h.house_value_max + h.house_value_min) / 2
            FROM CumulativeUnits h
            WHERE h.zipcode = t.zipcode AND h.cumulative_units >= t.total_units / 2
            LIMIT 1)
        ELSE
            (SELECT (h.house_value_max + COALESCE((LAG(h.house_value_max) OVER (PARTITION BY h.zipcode ORDER BY h.house_value_max)), 0)) / 2.0
            FROM CumulativeUnits h
            WHERE h.zipcode = t.zipcode AND h.cumulative_units >= t.total_units / 2
            LIMIT 1)
    END AS median
FROM
    TotalUnits t;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.042
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 194:
  NLQ: For each zipcode, count houses built in or after 2020.
  Predicted SQL: SELECT * FROM housing_year_built;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, number_of_units from housing_year_built where year_built_min = 2020;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.291
  Output Similarity: 0.000
  Execution Time: 0.012 seconds

Test 195:
  NLQ: Get percentage of zipcodes having GRAPI greater than 28% in year 2022
  Predicted SQL: SELECT * FROM housing_gross_rent_percent;
  Ground Truth SQL: SELECT 100*grapi_zipcodes/total as `Zipcodes with GRAPI greater than 28%` FROM
(SELECT 
    COUNT(h.zipcode) as grapi_zipcodes
FROM 
    (SELECT DISTINCT zipcode, SUM(a.number_of_units*(a.income_percent_max+a.income_percent_min)/2)/SUM(a.number_of_units) AS smocapi 
    FROM housing_gross_rent_percent AS a 
    WHERE year = 2022 
    GROUP BY zipcode 
    HAVING smocapi >= 30) AS h) as t1,
(SELECT COUNT(DISTINCT zipcode) as total
    FROM housing_gross_rent_percent
    WHERE year = 2022) as t2;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.089
  Output Similarity: 0.000
  Execution Time: 0.051 seconds

Test 196:
  NLQ: Get percentage of zipcodes having SMOCAPI greater than 30% in year 2022.
  Predicted SQL: SELECT * FROM household_income_percent_with_mortgage;
  Ground Truth SQL: SELECT 100*smocapi_zipcodes/total as `Zipcodes with SMOCAPI greater than 28%` FROM
(SELECT 
    COUNT(h.zipcode) as smocapi_zipcodes
FROM 
    (SELECT DISTINCT zipcode, SUM(a.number_of_units*(a.income_percent_max+a.income_percent_min)/2)/SUM(a.number_of_units) AS smocapi 
    FROM household_income_percent_with_mortgage AS a 
    WHERE year = 2022 
    GROUP BY zipcode 
    HAVING smocapi >= 30) AS h) as t1,
(SELECT COUNT(DISTINCT zipcode) as total
    FROM household_income_percent_with_mortgage 
    WHERE year = 2022) as t2;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.108
  Output Similarity: 0.000
  Execution Time: 0.042 seconds

Test 197:
  NLQ: Get average population of males and females by year in Georgia
  Predicted SQL: SELECT * FROM demographic_basics;
  Ground Truth SQL: select year, avg(total_population_male), avg(total_population_female) from demographic_basics group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.296
  Output Similarity: 0.000
  Execution Time: 0.015 seconds

Test 198:
  NLQ: For year 2022, get gender ratio between males and females for each zipcode in Georgia.
  Predicted SQL: SELECT * FROM demographic_basics;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, avg(total_population_male/total_population_female) from demographic_basics where year=2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.213
  Output Similarity: 0.000
  Execution Time: 0.015 seconds

Test 199:
  NLQ: For each year after 2016, get average count of each ethnicity in Georgia.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select year, avg(white) as 'white', avg(black) as 'black', avg(asian) as 'asian', avg(american_indian_and_alaska_native) as 'american_indian_and_alaska_native', 
avg(native_hawaiian_and_other_pacific_islander) as 'native_hawaiian_and_other_pacific_islander', avg(hispanic_or_latino) as 'hispanic_or_latino' 
from demographic_race where year > 2016 group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.083
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 200:
  NLQ: For year 2022, get average count of each ethnicity grouped by zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, avg(white), avg(black), avg(asian), avg(american_indian_and_alaska_native), avg(native_hawaiian_and_other_pacific_islander) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.135
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 201:
  NLQ: For year 2022, get percentage of American Indian and Alaskan Natives with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(american_indian_and_alaska_native)/avg(race_total_population) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.183
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 202:
  NLQ: For year 2022, get percentage of Asians with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(asian)/avg(race_total_population) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.220
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 203:
  NLQ: For year 2022, get percentage of Blacks with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(black)/avg(race_total_population) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.220
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 204:
  NLQ: For year 2022, get percentage of Hispanics/Latinos with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(hispanic_or_latino)/avg(hispanic_or_latino_total) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.197
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 205:
  NLQ: For year 2022, get percentage of Native Hawaiian and other Pacific Inlander with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(native_hawaiian_and_other_pacific_islander)/avg(race_total_population) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.174
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 206:
  NLQ: For year 2022, get percentage of Whites with respect to the total population in each zipcode.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, 100*avg(white)/avg(race_total_population) from demographic_race where year = 2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.220
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 207:
  NLQ: For each zipcode in Atlanta, get change in percentage of those travelling in car alone between year 2019 and 2022
  Predicted SQL: SELECT * FROM economic_commute_to_work;
  Ground Truth SQL: SELECT substring(economic_commute_to_work.zipcode, 7, 10) as zip, ((car_alone/total_workers)*100 - commute_old.public_transport_percent) as commute_change
FROM economic_commute_to_work 
join (select zipcode, (car_alone/total_workers)*100 as public_transport_percent
    from economic_commute_to_work where year=2019) as commute_old 
on commute_old.zipcode=economic_commute_to_work.zipcode
where economic_commute_to_work.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.092
  Output Similarity: 0.000
  Execution Time: 0.014 seconds

Test 208:
  NLQ: For each zipcode in Georgia, give the change in mean commute time between 2017 and 2022
  Predicted SQL: SELECT * FROM economic_commute_to_work;
  Ground Truth SQL: SELECT substring(economic_commute_to_work.zipcode, 7, 10) as zip, mean_travel_time - commute_old.mean_time as commute_change
FROM economic_commute_to_work 
join (select zipcode, mean_travel_time as mean_time
    from economic_commute_to_work where year=2017) as commute_old 
on commute_old.zipcode=economic_commute_to_work.zipcode
where economic_commute_to_work.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.104
  Output Similarity: 0.000
  Execution Time: 0.014 seconds

Test 209:
  NLQ: For each zipcode in Atlanta, get change in percentage of those working from home between year 2019 and 2022
  Predicted SQL: SELECT * FROM economic_commute_to_work;
  Ground Truth SQL: SELECT substring(economic_commute_to_work.zipcode, 7, 10) as zip, ((work_from_home/total_workers)*100 - commute_old.public_transport_percent) as work_from_home_change
FROM economic_commute_to_work 
join (select zipcode, (work_from_home/total_workers)*100 as public_transport_percent
    from economic_commute_to_work where year=2019) as commute_old 
on commute_old.zipcode=economic_commute_to_work.zipcode
where economic_commute_to_work.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.088
  Output Similarity: 0.000
  Execution Time: 0.014 seconds

Test 210:
  NLQ: For year 2022, get percentage of each commute type when commuting to work.
  Predicted SQL: SELECT * FROM economic_commute_to_work;
  Ground Truth SQL: select year, (sum(car_alone)/sum(total_workers))*100 as 'car_alone', (sum(car_pool)/sum(total_workers))*100 as 'car_pool', (sum(public_transport)/sum(total_workers))*100 as 'public_transport', (sum(walk)/sum(total_workers))*100 as 'walk', (sum(work_from_home)/sum(total_workers))*100 as 'work_from_home' 
from economic_commute_to_work
where year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.111
  Output Similarity: 0.000
  Execution Time: 0.014 seconds

Test 211:
  NLQ: Get median and mean household income for each year.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: SELECT year, avg(median_household_income) as `Median household income`, avg(mean_household_income) as `Mean household income` FROM economic_income_and_benefits group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.241
  Output Similarity: 0.000
  Execution Time: 0.010 seconds

Test 212:
  NLQ: Get percentage of households with and without mortgage for each year.
  Predicted SQL: SELECT * FROM housing_mortgage;
  Ground Truth SQL: select year, avg(units_with_mortgage) as `Units with mortgage`, avg(units_without_mortgage) as `Units without mortgage` from housing_mortgage group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.192
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 213:
  NLQ: Get mean commute time by zipcode in the year 2022.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, avg(mean_travel_time) from economic_commute_to_work where year=2022 group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.228
  Output Similarity: 0.000
  Execution Time: 0.010 seconds

Test 214:
  NLQ: For each zipcode in year 2022, get median household income.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: SELECT substring(zipcode, 7, 10) as zcta, avg(median_household_income), avg(mean_household_income) FROM economic_income_and_benefits WHERE year=2022 group by zcta;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.258
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 215:
  NLQ: For each zipcode, get change in averaged median household income from 2017 to 2022.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: SELECT substring(economic_income_and_benefits.zipcode, 7, 10) as zcta, avg(median_household_income) - median_2017.median_income FROM economic_income_and_benefits join
(SELECT zipcode, avg(median_household_income) as median_income FROM economic_income_and_benefits where year=2016 group by zipcode) median_2017
on economic_income_and_benefits.zipcode=median_2017.zipcode
WHERE year=2022 group by economic_income_and_benefits.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.097
  Output Similarity: 0.000
  Execution Time: 0.010 seconds

Test 216:
  NLQ: For each zipcode of Georgia, get median and mean household income over all the years.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: SELECT substring(zipcode, 7, 10) as zcta, avg(median_household_income), avg(mean_household_income) FROM economic_income_and_benefits group by zcta;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.286
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 217:
  NLQ: For each zipcode in Georgia, get the count of non-US citizens and foreign born population
  Predicted SQL: SELECT * FROM social_citizenship_status;
  Ground Truth SQL: select substring(zipcode,7,10) as zcta, foreign_born_population, not_a_us_citizen from social_citizenship_status where year=2022
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.297
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 218:
  NLQ: Get the average of each ethnic group (black, white, asian) by year.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: SELECT year, avg(black), avg(white), avg(asian) FROM demographic_race group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.357
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 219:
  NLQ: Get the percentage of types of education attained by population aged 25 and above for each year.
  Predicted SQL: SELECT * FROM social_education_attainment;
  Ground Truth SQL: select year, (sum(less_than_9th_grade)/sum(population_25_years_and_over))*100 as 'less_than_9th_grade', (sum(9th_to_12th_grade_no_diploma)/sum(population_25_years_and_over))*100 as '9th_to_12th', (sum(high_school_graduate)/sum(population_25_years_and_over))*100 as 'high_school_graduate', (sum(some_college_no_degree)/sum(population_25_years_and_over))*100 as 'some_college_no_degree', (sum(associate_degree)/sum(population_25_years_and_over))*100 as 'associate_degree', (sum(bachelors_degree)/sum(population_25_years_and_over))*100 as 'bachelors_degree', (sum(graduate_or_professional_degree)/sum(population_25_years_and_over))*100 as 'graduate_or_professional_degree' 
from social_education_attainment
group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.059
  Output Similarity: 0.000
  Execution Time: 0.016 seconds

Test 220:
  NLQ: For all years after 2016, for each zipcode, get percentage of households with a computer and percentage of housholds with broadband subscription.
  Predicted SQL: SELECT * FROM social_computer_internet_usage;
  Ground Truth SQL: select year, (sum(with_a_computer)/sum(total_households))*100 as 'with_computer', (sum(with_broadband_internet_subscription)/sum(total_households))*100 as 'broadband_connection' from social_computer_internet_usage where year>=2017 group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.184
  Output Similarity: 0.000
  Execution Time: 0.010 seconds

Test 221:
  NLQ: For each zipcode in Atlanta, give the change in average house rent from 2019 to 2022, i.e., from pre-COVID to post-COVID period.
  Predicted SQL: SELECT * FROM housing_rent;
  Ground Truth SQL: select substring(housing_rent.zipcode, 7, 10) as zcta, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) - h.rent_weighted_avg as decimal(8,2)) as rent_change
from housing_rent join 
(select zipcode, (sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as rent_weighted_avg
from housing_rent where year=2019 group by zipcode) as h on h.zipcode=housing_rent.zipcode
where year=2022 
group by housing_rent.zipcode
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.055
  Output Similarity: 0.000
  Execution Time: 0.062 seconds

Test 222:
  NLQ: For each zipcode in Georgia, give the change in average house rent from 2017 to 2022.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select substring(housing_value.zipcode, 7, 10) as zcta, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) - h.housing_value_weighted_avg as decimal(8,2)) as change_in_housing_value
from housing_value join 
(select zipcode, (sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as housing_value_weighted_avg
from housing_value where year=2017 group by zipcode) as h on h.zipcode=housing_value.zipcode
where year=2022 
group by housing_value.zipcode
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.053
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 223:
  NLQ: For each year, get rent and value of house averaged over all zip codes.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select STR_TO_DATE(CONCAT(house_rent_value.year, '-01-01'), '%Y-%m-%d') AS year_date, avg(rent_weighted_average) as rent, avg(house_value_weighted_average) as house_value 
from
(select rent_avg.*, house_value_avg.house_value_weighted_average
from (select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent
group by year, zipcode) as rent_avg, 
(select year, zipcode, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as house_value_weighted_average
from housing_value
group by year, zipcode) as house_value_avg
where rent_avg.year = house_value_avg.year and rent_avg.zipcode = house_value_avg.zipcode) as house_rent_value 
group by year;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.035
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 224:
  NLQ: For each zip code, get rent and value of house averaged over all years.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zip, avg(rent_weighted_average) as rent, avg(house_value_weighted_average) as house_value 
from
(select rent_avg.*, house_value_avg.house_value_weighted_average
from (select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent
group by year, zipcode) as rent_avg, 
(select year, zipcode, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as house_value_weighted_average
from housing_value
group by year, zipcode) as house_value_avg
where rent_avg.year = house_value_avg.year and rent_avg.zipcode = house_value_avg.zipcode) as house_rent_value 
group by zip;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.037
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 225:
  NLQ: For each zip code, get the average rent and maintenance cost for households without mortgage.
  Predicted SQL: SELECT * FROM household_income_percent_without_mortgage;
  Ground Truth SQL: select substring(rent_affordability.zipcode, 7, 10) as zcta, rent_affordability.rent_weighted_avg, maintenance_costs.maintenance_weighted_avg_without_mortgage
from 
(select zipcode, (sum(number_of_units*((income_percent_min+income_percent_max)/2))/sum(number_of_units)) as maintenance_weighted_avg_without_mortgage from household_income_percent_without_mortgage where year=2022 group by zipcode) as maintenance_costs,
(select zipcode, (sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as rent_weighted_avg from housing_rent where year=2022 group by zipcode) as rent_affordability
where maintenance_costs.zipcode = rent_affordability.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.084
  Output Similarity: 0.000
  Execution Time: 0.059 seconds

Test 226:
  NLQ: For year 2022 and for each zipcode, get average rent value and house price.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select rent_avg.year, rent_avg.zipcode, rent_avg.rent_weighted_average, house_value_avg.house_value_weighted_average
from (select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent
group by year, zipcode) as rent_avg, 
(select year, zipcode, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as house_value_weighted_average
from housing_value
group by year, zipcode) as house_value_avg
where rent_avg.year = house_value_avg.year and rent_avg.zipcode = house_value_avg.zipcode and rent_avg.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.042
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 227:
  NLQ: For each zipcode, get average rent value and house price.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zip, avg(rent_weighted_average) as rent, avg(house_value_weighted_average) as house_value 
from
(select rent_avg.*, house_value_avg.house_value_weighted_average
from (select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent
group by year, zipcode) as rent_avg, 
(select year, zipcode, cast((sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as house_value_weighted_average
from housing_value
group by year, zipcode) as house_value_avg
where rent_avg.year = house_value_avg.year and rent_avg.zipcode = house_value_avg.zipcode) as house_rent_value 
group by zip;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.037
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 228:
  NLQ: Get total housing units in 2022 grouped by zipcode.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select substring(zipcode, 7, 10) as zcta, sum(total_units) as total_units from
(select zipcode, sum(number_of_units) as total_units from housing_value where year=2022 group by zipcode union all select zipcode, sum(number_of_units) as total_units from housing_rent where year=2022 group by zipcode) h group by zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.085
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 229:
  NLQ: For all years after 2016, for each zipcode get percentage of marginalized communities (black, asian, american indian & alaskan native, native hawaiian & pacific inlander) and average SMOCAPI.
  Predicted SQL: SELECT * FROM demographic_race;
  Ground Truth SQL: select substring(demographic_race.zipcode,7,10) as zcta, 100*(avg(black) + avg(asian) + avg(american_indian_and_alaska_native) + avg(native_hawaiian_and_other_pacific_islander))/avg(race_total_population) as 'Percent Marginalized Communities', sum(number_of_units*(income_percent_max+income_percent_min)/2)/sum(number_of_units) as smocapi
from demographic_race join household_income_percent_with_mortgage on demographic_race.zipcode=household_income_percent_with_mortgage.zipcode where demographic_race.year>2016 and household_income_percent_with_mortgage.year>2016
group by demographic_race.zipcode
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.050
  Output Similarity: 0.000
  Execution Time: 0.018 seconds

Test 230:
  NLQ: For each zipcode, get mean commute time and average housing value.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: select substring(housing_affordability.zipcode, 7, 10) as zcta, housing_affordability.housing_value_weighted_avg, mean_commute.mean_time
from 
(select zipcode, avg(mean_travel_time) as mean_time from economic_commute_to_work where year=2022 group by zipcode) as mean_commute,
(select zipcode, (sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as housing_value_weighted_avg from housing_value where year=2022 group by zipcode) as housing_affordability
where mean_commute.zipcode = housing_affordability.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.076
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 231:
  NLQ: Get average housing rent and mean household income across all zipcodes for the year 2022.
  Predicted SQL: SELECT * FROM housing_rent;
  Ground Truth SQL: select rent_avg.*, economic_income_and_benefits.mean_household_income
from (select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent
group by year, zipcode) as rent_avg, economic_income_and_benefits
where rent_avg.year = economic_income_and_benefits.year and rent_avg.zipcode = economic_income_and_benefits.zipcode and rent_avg.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.060
  Output Similarity: 0.000
  Execution Time: 0.061 seconds

Test 232:
  NLQ: For each zipcode, get percentage of units with mortgage and median household income.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: select m.zipcode, avg(units_with_mortgage)/avg(units_with_mortgage+units_without_mortgage), avg(median_household_income)
from housing_mortgage as m join economic_income_and_benefits as e on m.zipcode=e.zipcode
group by m.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.183
  Output Similarity: 0.000
  Execution Time: 0.010 seconds

Test 233:
  NLQ: For each zipcode in the year 2022, get average housing value and median household income.
  Predicted SQL: SELECT * FROM economic_income_and_benefits;
  Ground Truth SQL: SELECT
  `source`.`zipcode` AS `zipcode`,
  `source`.`house_value_weighted_average` AS `house_value_weighted_average`,
  `Economic Income And Benefits`.`median_household_income` AS `Economic Income And Benefits__median_household_income`
FROM
  (
    select
      zipcode,
      cast(
        (
          sum(
            number_of_units * ((house_value_min + house_value_max) / 2)
          ) / sum(number_of_units)
        ) as decimal(8, 2)
      ) as house_value_weighted_average
    from
      housing_value
    where
      year = 2022
    group by
      zipcode
  ) AS `source`
 
LEFT JOIN `economic_income_and_benefits` AS `Economic Income And Benefits` ON `source`.`zipcode` = `Economic Income And Benefits`.`zipcode`
WHERE
  `Economic Income And Benefits`.`year` = 2022
LIMIT
  1048575
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.062
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 234:
  NLQ: For each zipcode of Georgia, find the change in percentage of population with no health insurance from year 2017 to 2022.
  Predicted SQL: SELECT * FROM economic_health_insurance;
  Ground Truth SQL: SELECT substring(economic_health_insurance.zipcode, 7, 10) as zip, 100*no_health_insurance/total_population - avg_no_health_insurance.a as change_from_average
FROM economic_health_insurance 
join (select zipcode, avg(100*no_health_insurance/total_population) as a
    from economic_health_insurance where year=2017 group by zipcode) as avg_no_health_insurance 
on avg_no_health_insurance.zipcode=economic_health_insurance.zipcode
where economic_health_insurance.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.086
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 235:
  NLQ: For each zipcode in year 2022, get percentage of population with no health insurance and average house rent.
  Predicted SQL: SELECT * FROM economic_health_insurance;
  Ground Truth SQL: select health_ins.*, rent_avg.rent_weighted_average from 
(SELECT year, zipcode, 100*(no_health_insurance/total_population) as no_health_insurance
FROM economic_health_insurance 
where economic_health_insurance.year=2022) as health_ins,
(select year, zipcode, cast((sum(number_of_units*((rent_value_min+rent_value_max)/2))/sum(number_of_units)) as decimal(8,2)) as rent_weighted_average
from housing_rent group by year, zipcode) as rent_avg
where rent_avg.zipcode = health_ins.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.083
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 236:
  NLQ: For each zipcode in year 2022, get percentage of population with no health insurance and average housing price.
  Predicted SQL: SELECT * FROM economic_health_insurance;
  Ground Truth SQL: select health_ins.*, housing_val.housing_value_weighted_avg from 
(SELECT year, zipcode, 100*(no_health_insurance/total_population) as no_health_insurance
FROM economic_health_insurance 
where economic_health_insurance.year=2022) as health_ins,
(select zipcode, (sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as housing_value_weighted_avg
from housing_value where year=2022 group by zipcode) as housing_val
where housing_val.zipcode = health_ins.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.082
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

Test 237:
  NLQ: For each zipcode in Georgia, get the change in percentage of population commuting via public transport from year 2017 to 2022.
  Predicted SQL: SELECT * FROM economic_commute_to_work;
  Ground Truth SQL: SELECT substring(economic_commute_to_work.zipcode, 7, 10) as zip, ((public_transport/total_workers)*100 - commute_old.public_transport_percent) as commute_change
FROM economic_commute_to_work 
join (select zipcode, (public_transport/total_workers)*100 as public_transport_percent
    from economic_commute_to_work where year=2017) as commute_old 
on commute_old.zipcode=economic_commute_to_work.zipcode
where economic_commute_to_work.year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.089
  Output Similarity: 0.000
  Execution Time: 0.014 seconds

Test 238:
  NLQ: In year 2022, for each zipcode in Georgia, get the percentage of population with associate and bachelors degree or higher and average housing price.
  Predicted SQL: SELECT * FROM social_education_attainment;
  Ground Truth SQL: select substring(h.zipcode, 7, 10) as zcta, ((associate_degree+bachelors_degree_or_higher)/population_25_years_and_over)*100 as education_attaimnemt_percent, h.housing_value_weighted_avg
from social_education_attainment join 
(select zipcode, (sum(number_of_units*((house_value_min+house_value_max)/2))/sum(number_of_units)) as housing_value_weighted_avg
from housing_value where year=2022 group by zipcode) as h on h.zipcode=social_education_attainment.zipcode
where year=2022;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.088
  Output Similarity: 0.000
  Execution Time: 0.016 seconds

Test 239:
  NLQ: For all years after 2016, for each zipcode get average housing  price and percentage of houses having broadband subscription.
  Predicted SQL: SELECT * FROM housing_value;
  Ground Truth SQL: select h.zipcode, sum(number_of_units*(house_value_min+house_value_max)/2)/sum(number_of_units), avg(with_a_computer)/avg(total_households), avg(with_broadband_internet_subscription)/avg(total_households)
from housing_value as h join social_computer_internet_usage as s on h.zipcode=s.zipcode
where h.year > 2016 and s.year > 2016
group by h.zipcode;
-- select * from social_computer_internet_usage where year>2016
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.068
  Output Similarity: 0.000
  Execution Time: 0.070 seconds

Test 240:
  NLQ: For all years after 2016, for each zipcode get average housing  rent and percentage of houses having broadband subscription.
  Predicted SQL: SELECT * FROM housing_rent;
  Ground Truth SQL: select h.zipcode, sum(number_of_units*(rent_value_min+rent_value_max)/2)/sum(number_of_units), avg(with_a_computer)/avg(total_households), avg(with_broadband_internet_subscription)/avg(total_households)
from housing_rent as h join social_computer_internet_usage as s on h.zipcode=s.zipcode
where h.year > 2016 and s.year > 2016
group by h.zipcode;
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.078
  Output Similarity: 0.000
  Execution Time: 0.061 seconds

Test 241:
  NLQ: Get count of mass shootings for each month in USA.
  Predicted SQL: SELECT * FROM us_shootings;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) AS `IncidentDate`,
  COUNT(*) AS `count`
FROM
  `us_shootings`
GROUP BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.069
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 242:
  NLQ: Get count of suspects arrested each month over the years.
  Predicted SQL: SELECT * FROM us_shootings;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) AS `IncidentDate`,
  SUM(`us_shootings`.`SuspectsArrested`) AS `sum`,
  AVG(`us_shootings`.`SuspectsArrested`) AS `avg`
FROM
  `us_shootings`
GROUP BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.055
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 243:
  NLQ: Get count of victims injured, suspects arrested and suspects killed for each incident.
  Predicted SQL: SELECT * FROM us_shootings;
  Ground Truth SQL: SELECT SUM(VictimsInjured) AS VictimsInjured, Sum(SuspectsArrested) AS SuspectsArrested, SUM(SuspectsKilled) AS SuspectsKilled, IncidentDate FROM us_shootings WHERE IncidentDate != '20171001' GROUP BY IncidentDate
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.117
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 244:
  NLQ: For each month, get count of victims killed and average of victims killed in each shooting incident.
  Predicted SQL: SELECT * FROM us_shootings;
  Ground Truth SQL: SELECT
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) AS `IncidentDate`,
  SUM(`us_shootings`.`VictimsKilled`) AS `sum`,
  AVG(`us_shootings`.`VictimsKilled`) AS `avg`
FROM
  `us_shootings`
GROUP BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  )
ORDER BY
  STR_TO_DATE(
    CONCAT(
      DATE_FORMAT(`us_shootings`.`IncidentDate`, '%Y-%m'),
      '-01'
    ),
    '%Y-%m-%d'
  ) ASC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.056
  Output Similarity: 0.000
  Execution Time: 0.008 seconds

Test 245:
  NLQ: Get count of homeless population and US shooting incidents for each year.
  Predicted SQL: SELECT * FROM experiencing_homelessness_age_demographics;
  Ground Truth SQL: SELECT * FROM 
(SELECT Count(*) as IncidentCount, year(IncidentDate) as IncidentYear   FROM us_shootings GROUP BY IncidentYear) T1
JOIN
(SELECT sum(EXPERIENCING_HOMELESSNESS_CNT) as HomelessnessCount, CALENDAR_YEAR FROM experiencing_homelessness_age_demographics group by CALENDAR_YEAR) T2
ON T2.CALENDAR_YEAR = T1.IncidentYear 
ORDER BY IncidentCount DESC 
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.159
  Output Similarity: 0.000
  Execution Time: 0.003 seconds

Test 246:
  NLQ: Get homeless population per capita for each county of California.
  Predicted SQL: SELECT * FROM experiencing_homelessness_age_demographics;
  Ground Truth SQL: SELECT T2.County, (CAST(T1.HomelessnessCount AS decimal) / CAST((T2.PopulationCountSum) AS decimal)) AS HomelessnessCountCapita FROM
(SELECT sum(EXPERIENCING_HOMELESSNESS_CNT) as HomelessnessCount, lower(LOCATION) as Area FROM experiencing_homelessness_age_demographics WHERE LOCATION NOT LIKE "california" group by Area order by HomelessnessCount) T1
join
(SELECT County, Sum(PopulationCount) as PopulationCountSum FROM us_population_county GROUP BY County) T2
ON T1.Area LIKE concat('%', T2.County, '%')
ORDER BY HomelessnessCountCapita DESC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.179
  Output Similarity: 0.000
  Execution Time: 0.003 seconds

Test 247:
  NLQ: Get homeless population per capita and US shooting incidents per million capita for each county of California.
  Predicted SQL: SELECT * FROM experiencing_homelessness_age_demographics;
  Ground Truth SQL: 

SELECT T5.County, T5.HomelessnessCountCapita, T6.ShootingsPerMillionCapita FROM
(
SELECT T2.County , (CAST(T1.HomelessnessCount AS decimal) / CAST((T2.PopulationCountSum) AS decimal)) AS HomelessnessCountCapita FROM
(SELECT sum(EXPERIENCING_HOMELESSNESS_CNT) as HomelessnessCount, lower(LOCATION) as Area FROM experiencing_homelessness_age_demographics WHERE LOCATION NOT LIKE "california" AND CALENDAR_YEAR=2020 AND LOCATION NOT LIKE '%(los angeles county)%' group by Area order by HomelessnessCount) T1
join
(SELECT County, Sum(PopulationCount) as PopulationCountSum FROM us_population_county GROUP BY County) T2
ON T1.Area LIKE concat('%', T2.County, '%')
) T5
JOIN
(
SELECT T4.County, (CAST(T3.IncidentCount AS decimal) / CAST((T4.PopulationCount/1000000) AS decimal)) AS ShootingsPerMillionCapita FROM 
(SELECT CityOrCounty, Count(*) AS IncidentCount from us_shootings GROUP BY CityOrCounty) T3
JOIN 
(SELECT County, PopulationCount FROM us_population_county GROUP BY County, PopulationCount) T4
ON T3.CityOrCounty LIKE T4.County
) T6
ON T5.County LIKE concat('%', T6.County, '%')
ORDER BY ShootingsPerMillionCapita DESC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.140
  Output Similarity: 0.000
  Execution Time: 0.003 seconds

Test 248:
  NLQ: For each county, get shooting incidents per million capita, and income per million capita.
  Predicted SQL: SELECT * FROM food_access;
  Ground Truth SQL: SELECT T5.County, T5.MedianFamilyIncomePerMillionCapita, T6.ShootingsPerMillionCapita FROM
(
SELECT T2.County , (CAST(T1.MedianFamilyIncome AS decimal) / CAST((T2.PopulationCountSum/1000000) AS decimal)) AS MedianFamilyIncomePerMillionCapita FROM
(SELECT avg(MedianFamilyIncome) as MedianFamilyIncome, lower(County) as Area FROM food_access group by Area order by MedianFamilyIncome) T1
join
(SELECT County, Sum(PopulationCount) as PopulationCountSum FROM us_population_county GROUP BY County) T2
ON T1.Area LIKE concat('%', T2.County, '%')
) T5
JOIN
(
SELECT T4.County, (CAST(T3.IncidentCount AS decimal) / CAST((T4.PopulationCount/1000000) AS decimal)) AS ShootingsPerMillionCapita FROM 
(SELECT CityOrCounty, Count(*) AS IncidentCount from us_shootings GROUP BY CityOrCounty) T3
JOIN 
(SELECT County, PopulationCount FROM us_population_county GROUP BY County, PopulationCount) T4
ON T3.CityOrCounty LIKE T4.County
) T6
ON T5.County LIKE concat('%', T6.County, '%')
ORDER BY ShootingsPerMillionCapita DESC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.024
  Output Similarity: 0.000
  Execution Time: 1.026 seconds

Test 249:
  NLQ: For each state, get shooting incidents per million capita, and income per million capita.
  Predicted SQL: SELECT * FROM food_access;
  Ground Truth SQL: SELECT T5.State, T5.MedianFamilyIncomePerMillionCapita, T6.ShootingsPerMillionCapita FROM
(
SELECT T2.State , (CAST(T1.MedianFamilyIncome AS decimal) / CAST((T2.PopulationCountSum/1000000) AS decimal)) AS MedianFamilyIncomePerMillionCapita FROM
(SELECT avg(MedianFamilyIncome) as MedianFamilyIncome, lower(State) as State FROM food_access group by State order by MedianFamilyIncome) T1
join
(SELECT State, Sum(PopulationCount) as PopulationCountSum FROM us_population GROUP BY State) T2
ON T1.State LIKE concat('%', T2.State, '%')
) T5
JOIN
(
SELECT T4.State, (CAST(T3.IncidentCount AS decimal) / CAST((T4.PopulationCount/1000000) AS decimal)) AS ShootingsPerMillionCapita FROM 
(SELECT State, Count(*) AS IncidentCount from us_shootings GROUP BY State) T3
JOIN 
(SELECT State, PopulationCount FROM us_population GROUP BY State, PopulationCount) T4
ON T3.State LIKE T4.State
) T6
ON T5.State LIKE concat('%', T6.State, '%')
ORDER BY ShootingsPerMillionCapita DESC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.025
  Output Similarity: 0.000
  Execution Time: 1.031 seconds

Test 250:
  NLQ: For each county, get victims killed per million capita, victims injured per million capita, suspects arrested per million capita, and incident counts for million capita.
  Predicted SQL: SELECT * FROM us_shootings;
  Ground Truth SQL: SELECT T1.County, (CAST(T1.VictimsKilled as decimal) / CAST((T2.PopulationCount/1000000) AS decimal)) AS VictimsKilledPerCapita, (CAST(T1.VictimsInjured as decimal) / CAST((T2.PopulationCount/1000000) AS decimal)) AS VictimsInjuredPerCapita,
(CAST(T1.IncidentCount as decimal) / CAST((T2.PopulationCount/1000000) AS decimal)) AS IncidentCountPerCapita, (CAST(T1.SuspectsArrested as decimal) / CAST((T2.PopulationCount/1000000) AS decimal)) AS SuspectsArrestedPerCapita FROM
(Select sum(VictimsKilled) as VictimsKilled, SUM(VictimsInjured) as VictimsInjured, Count(*) AS IncidentCount, Sum(SuspectsArrested) AS SuspectsArrested, lower(CityOrCounty) as County from us_shootings group by County) T1
JOIN 
(SELECT County, Sum(PopulationCount) as PopulationCount FROM us_population_county GROUP BY County) T2
ON T2.County LIKE T1.County
ORDER BY VictimsKilledPerCapita DESC
  Exact Match: False
  Execution Match: False
  Structural Similarity: 0.030
  Output Similarity: 0.000
  Execution Time: 0.009 seconds

===== Overall Results =====
Exact Match (EM): 0.000
Execution Match (EX): 0.000
Average Structural Similarity: 0.123
Average Output Similarity: 0.000
Average Execution Time: 0.846 seconds
```

---

### Why this was interesting

This wasn’t just a “toy demo” — it was a full pipeline connecting **LLMs → reasoning steps → SQL → execution → evaluation metrics**.  
I could clearly see the difference between *naive SQL generation* and the more structured **ReAct-style prompting** that breaks down queries step by step.  

It gave me a better sense of how LLMs can be applied in real database interfaces, and why evaluation frameworks are critical for moving beyond simple demos.  

---

### Technology Stack

* **LLM Integration** – Groq API (production model: `llama-3.1-8b-instant`)  
* **Prompting Techniques** – ReAct pipeline for query decomposition + refinement  
* **Database** – SQLite with generated tables from CSV data  
* **Evaluation** – structural/output similarity metrics, execution match, exact match  
* **Supporting Tools** – data augmentation with paraphrased NLQs  

---
